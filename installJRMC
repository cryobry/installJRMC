#!/usr/bin/env bash
# This script will install JRiver Media Center and associated services
# on Fedora, CentOS, Debian, and Ubuntu
#
# Copyright (c) 2021 Bryan C. Roessler
# This software is released under the Apache License.
# https://www.apache.org/licenses/LICENSE-2.0
#
# See installJRMC --help or printHelp() below
#
# TODO
#   1. Raspberry Pi OS support
#   2. Interactive installation (ncurses?)
#   3. Additional containerization (createrepo and rpmbuild)
#   4. Tests
#
# BUGS
#   1. No createrepo on Mint

shopt -s extglob

declare -g SCRIPTVERSION="1.0b6"
declare -g OUTPUTDIR="$PWD/output"
declare -g CREATEREPO_WEBROOT="/var/www/jriver"
declare -g USER && USER="${USER:-$(id -un)}"
declare -g USER_HOME && USER_HOME=$(grep "$USER" < /etc/passwd | cut -d":" -f6)

# MC version
# MCVERSION="28.0.87" # to set manually, if unset use automatic latest check

printHelp() {
    debug "Running: ${FUNCNAME[0]}"

    cat <<- 'EOF'
		USAGE:
		    installJRMC [[OPTION] [VALUE]]...

		    If no options (besides -d) are provided, the script will default to '--install repo'.

		OPTIONS
		    --install, -i repo|rpm|deb
		        repo: Install MC from repository, updates are handled by the system package manager
		        rpm: Build and install RPM locally (RPM-based distros only)
		            deb: Download and install offcial MC package locally (useful with --compat flag for older distros)
		    --build
		        Build RPM from source DEB but do not install. Optional TARGET parameter enables RPM crossbuilding (ex. 'opensuse', 'fedora', 'centos')
		    --target opensuse|fedora|centos
		        Cross-build RPM or createrepo for target distro
		    --mcversion VERSION
		        Specify the MC version, ex. "28.0.94" (Default: latest)
		    --outputdir PATH
		        Generate rpmbuild output in this directory (Default: ./output)
		    --restorefile RESTOREFILE
		        Restore file location for automatic license registration (Default: skip registration)
		    --betapass PASSWORD
		        Enter beta team password for access to beta builds
		    --service, -s SERVICE
		        See SERVICES section below for a list of possible services to install
		      --service-type user|system
		          Starts services at boot (system) or at user login (user) (Default: boot)
		    --container, -c CONTAINER (TODO: Under construction)
		        See CONTAINERS section below for a list of possible services to install
		    --createrepo
		        Build rpm, copy to webroot, and run createrepo. Use in conjunction with --build=TARGET for crossbuilding repos
		        --createrepo-webroot PATH
		            Specify the webroot directory to install the repo (Default: /var/www/jriver)
		        --createrepo-user USER
		            Specify the web server user if it differs from $USER
		    --compat
		        Build/install RPM without minimum library specifiers
		    --version, -v
		        Print this script version and exit
		    --debug, -d
		        Print debug output
		    --help, -h
		        Print help dialog and exit
		    --uninstall, -u
		        Uninstall JRiver MC, remove services, and remove firewall rules (does not remove library files)

		SERVICES
		    jriver-mediaserver
		        Enable and start a mediaserver systemd service (requires an existing X server)
		    jriver-mediacenter
		        Enable and start a mediacenter systemd service (requires an existing X server)
		    jriver-x11vnc
		        Enable and start x11vnc for the local desktop (requires an existing X server)
		        Usually combined with jriver-mediaserver or jriver-mediacenter services
		        --vncpass and --display are optional (see below)
		    jriver-xvnc
		        Enable and start a new Xvnc session running JRiver Media Center
		        --vncpass PASSWORD
		            Set vnc password for x11vnc/Xvnc access. If no password is set, the script
		            will either use existing password stored in ~/.vnc/jrmc_passwd or use no password
		        --display DISPLAY
		            Display to start x11vnc/Xvnc (Default: The current display (x11vnc) or the
		            current display incremented by 1 (Xvnc))
		    jriver-createrepo
		        Install hourly service to build latest MC RPM and run createrepo ()

		CONTAINERS (TODO: Under construction)
		    mediacenter-xvnc
		    createrepo
	EOF
}


init() {
    debug "Running: ${FUNCNAME[0]}"

    declare version_source
    declare -g MCVERSION MVERSION MCRPM
    declare -g CREATEREPO_USER="${CREATEREPO_USER:-$USER}"

    getOS

    # Make sure universe repo is installed on Ubuntu
    if [[ "$ID" == "ubuntu|neon" ]]; then
        if ! grep ^deb /etc/apt/sources.list|grep -q universe; then
            sudo add-apt-repository universe
        fi
    fi
   
    # Agnostic commands
    bash_cmd(){ sudo bash -c "$@"; }
    cp_cmd(){ sudo cp -nf "$@"; }
    mkdir_cmd(){ sudo mkdir -p "$@"; }
    chown_cmd(){ sudo chown "$1":"$1" -R "${@:2}"; }
    ln_cmd(){ sudo ln -s "$@"; }

    # OS-specific commands
    if [[ "$ID" =~ ^(fedora|centos)$ ]]; then
        pkg_install(){ sudo dnf install -y "$@"; }
        pkg_remove(){ sudo dnf remove -y "$@"; }
        pkg_update(){ sudo dnf makecache; }
        pkg_query(){ rpm -q "$@"; }
        firewall_cmd(){ sudo firewall-cmd "$@"; }
    elif [[ "$ID" =~ ^(debian|ubuntu|linuxmint|neon)$ ]]; then
        pkg_install(){ sudo apt-get install -y -q0 "$@"; }
        pkg_remove(){ sudo apt-get remove --auto-remove -y -q0 "$@"; }
        pkg_update(){ sudo apt-get update -y -q0; }
        pkg_query(){ dpkg -s "$@"; }
        firewall_cmd(){ sudo ufw "$@"; }
    elif [[ "$ID" =~ ^opensuse.* ]]; then
        pkg_install(){ sudo zypper --non-interactive -q install --force --no-confirm "$@"; }
        pkg_remove(){ sudo zypper --non-interactive -q remove --clean-deps "$@"; }
        pkg_update(){ sudo zypper --non-interactive -q refresh jriver; }
        pkg_query(){ rpm -q "$@"; }
        firewall_cmd(){ sudo firewall-cmd "$@"; }
    fi

    parseInput "$@"

    # Select MC version to work with
    if [[ -v MCVERSION ]]; then
        version_source="user input"
    else
        getLatestVersion
    fi
    [[ ! "$MCVERSION" =~ ([0-9]+.[0-9]+.[0-9]+) ]] && err "Invalid version number" && exit 1

    echo "Using MC version $MCVERSION determined by $version_source"
    [[ "$version_source" != "user input" ]] && echo "To override, use --mcversion"

    # Extract major version number
    MVERSION="${MCVERSION%%.*}"

    # Set target package name
    if [[ "$ID" =~ ^(fedora|centos|opensuse.*)$ ]]; then
        MCRPM="MediaCenter"
        [[ "$version_source" == "user input" ]] && MCRPM="$MCRPM-$MCVERSION"
    elif [[ "$ID" =~ ^(debian|ubuntu|linuxmint|neon)$ ]]; then
        MCRPM="mediacenter$MVERSION"
        [[ "$version_source" == "user input" ]] && MCRPM="$MCRPM=$MCVERSION"
    fi

    # Saving this substituion in case it's needed in the future
    # _variation="${MCVERSION##*.}"
}

# Helpers
debug() { (( DEBUG )) && [[ $# -gt 0 ]] && echo "Debug: $*"; }
err() { echo "Error: $*" >&2; }
askOk() {
    declare response
    read -r -p "$* [y/N]" response
    [[ "${response,,}" =~ ^(yes|y)$ ]]
    return $?
}
getOS() {
    if [[ -e "/etc/os-release" ]]; then
        source "/etc/os-release"
    else
        err "/etc/os-release not found"
        err "Your OS is unsupported"
        printHelp && exit 1
    fi
    debug "Platform: $ID $VERSION_ID"
}


# ifSudo() {
#     declare user="root"
#     if [[ $# == 0 ]]; then
#         [[ "$USER" == "root" ]]
#         return $?
#     elif [[ $# -eq 2 && "$1" == "-u" ]]; then
#         user="$2"
#         [[ "$USER" == "$user" ]]
#         return $?
#     elif [[ $# -gt 2 && "$1" == "-u" ]]; then
#         user="$2"
#         shift 2
#     fi
#     if [[ "$user" == "$USER" ]]; then
#         "$@"
#     else
#         sudo -u "$user" "$@"
#     fi
# }


parseInput() {
    debug "Running: ${FUNCNAME[0]}"

    declare -g RPM_BUILD_SWITCH REPO_INSTALL_SWITCH COMPAT_SWITCH CREATEREPO_SWITCH UNINSTALL_SWITCH DEB_INSTALL_SWITCH
    declare -g INSTALL_TYPE TARGET OUTPUTDIR MCVERSION RESTOREFILE BETAPASS SERVICE_TYPE VNCPASS USER_DISPLAY CREATEREPO_WEBROOT CREATEREPO_USER
    declare -ga SERVICES CONTAINERS

    if [[ $# -eq 0 ]] || [[ $# -eq 1 && "$1" =~ ^(--debug|-d)$ ]]; then
        echo "No options passed, defaulting to repo installation method"
        INSTALL_TYPE="repo"
    fi

    if _input=$(getopt -o +i:vdhus:c: -l install:,build,target:,outputdir:,mcversion:,restorefile:,betapass:,service-type:,service:,version,debug,help,uninstall,createrepo,createrepo-webroot:,createrepo-user:,vncpass:,display:,container:,tests,compat -- "$@"); then
        eval set -- "$_input"
        while true; do
            case "$1" in
                --install|-i)
                    shift 
                    INSTALL_TYPE="$1"
                    [[ "$INSTALL_TYPE" == "rpm" ]] && RPM_BUILD_SWITCH=1
                    [[ "$INSTALL_TYPE" == "deb" ]] && DEB_INSTALL_SWITCH=1
                    [[ "$INSTALL_TYPE" == "repo" ]] && REPO_INSTALL_SWITCH=1
                    ;;
                --build)
                    RPM_BUILD_SWITCH=1
                    ;;
                --target)
                    shift && TARGET="$1"
                    ;;
                --outputdir)
                    shift && OUTPUTDIR="$1"
                    ;;
                --mcversion)
                    shift && MCVERSION="$1"
                    ;;
                --restorefile)
                    shift && RESTOREFILE="$1"
                    ;;
                --betapass)
                    shift && BETAPASS="$1"
                    ;;
                --service-type)
                    shift && SERVICE_TYPE="$1"
                    ;;
                --service|-s)
                    shift && SERVICES+=("$1")
                    ;;
                --createrepo)
                    RPM_BUILD_SWITCH=1
                    CREATEREPO_SWITCH=1
                    ;;
                --createrepo-webroot)
                    shift && CREATEREPO_WEBROOT="$1"
                    ;;
                --createrepo-user)
                    shift && CREATEREPO_USER="$1"
                    ;;
                --vncpass)
                    shift && VNCPASS="$1"
                    ;;
                --display)
                    shift && USER_DISPLAY="$1"
                    ;;
                --compat)
                    COMPAT_SWITCH=1
                    ;;
                --container|-c)
                    shift && CONTAINERS+=("$1")
                    ;;
                --version|-v)
                    echo "Version: $SCRIPTVERSION"
                    exit 0
                    ;;
                --debug|-d)
                    echo "Debugging on"
                    echo "installJRMC version: $SCRIPTVERSION"
                    DEBUG=1
                    ;;
                --help|-h)
                    printHelp && exit $?
                    ;;
                --uninstall|-u)
                    UNINSTALL_SWITCH=1
                    ;;
                --tests)
                    echo "Running tests, all other options are skipped"
                    tests
                    ;;
                --)
                    shift
                    break
                    ;;
            esac
            shift
        done
    else
        err "Incorrect options provided"
        printHelp && exit 1
    fi
}


#######################################
# Use several methods to determine the latest JRiver MC version
#######################################
getLatestVersion() {
    debug "Running: ${FUNCNAME[0]}"

    declare -g MCVERSION BASE BOARDURL
    declare cnt

    # Latest defaults
    BASE="buster" # For container method
    BOARDURL="https://yabb.jriver.com/interact/index.php/board,71.0.html" # MC28 (Buster), for fallback webscrape
    #BASE_next="bullseye" # TODO use for fallback to smooth upgrades

    # Legacy
    #boardurl26="https://yabb.jriver.com/interact/index.php/board,64.0.html" # jessie/stretch

    # Peg older versions to prevent ABI and dependency mismatches in automatic mode
    # This can be overriden w/ --mcversion
    # TODO need user input here
    # disable version checks for createrepo or rpmbuild (servers)
    # if [[ -v INSTALL_TYPE ]]; then
    #     if [[ "$ID" == "ubuntu" ]]; then
    #         # [[ "$VERSION_CODENAME" =~ ^(focal|groovy|hirsute|impish)$ ]] &&
    #         #     BASE="bullseye"
    #         [[ "$VERSION_CODENAME" =~ ^(cosmic|disco|eoan)$ ]] &&
    #             BASE="buster"
    #         [[ "$VERSION_CODENAME" =~ ^(xenial|yakkety|zesty|artful|bionic)$ ]] &&
    #             MCVERSION="26.0.107"
    #         [[ "$VERSION_CODENAME" =~ ^(trusty|utopic|vivid|wily)$ ]] &&
    #             MCVERSION="26.0.107" 
    #     elif [[ "$ID" == "debian" ]]; then
    #         BASE="$VERSION_CODENAME"
    #         [[ $VERSION_ID -eq 10 ]] &&
    #             BASE="buster"
    #         [[ $VERSION_ID -le 9 ]] &&
    #             MCVERSION="26.0.107" # For 9 and 8
    #     elif [[ "$ID" == "centos" ]]; then
    #         [[ "$VERSION_ID" -eq "8" ]] &&
    #             BASE="buster"
    #         [[ "$VERSION_ID" -lt "8" ]] &&
    #             MCVERSION="26.0.107" # Doubtful
    #     fi

    #     [[ -v MCVERSION ]] &&
    #         version_source="compatibility lookup" &&
    #         debug "To override, use --MCVERSION" &&
    #         return 0
    # fi

    # Use a containerized package manager
    # TODO but how to determine build distro ($BASE=buster)?
    installPackage --silent buildah
    if cnt=$(buildah from debian:$BASE) &>/dev/null; then 
        buildah run "$cnt" -- bash -c \
            "echo 'deb [trusted=no arch=amd64,i386,armhf,arm64] http://dist.jriver.com/latest/mediacenter/ $BASE main' > /etc/apt/sources.list 2>&1"
        buildah run "$cnt" -- bash  -c \
            "apt-get update --allow-insecure-repositories &>/dev/null"
        if MCVERSION=$(buildah run "$cnt" -- apt-cache policy mediacenter?? | grep Candidate | awk '{print $2}' | sort -V | tail -n1) \
            && [[ "$MCVERSION" =~ ([0-9]+.[0-9]+.[0-9]+) ]]; then
            version_source="containerized package manager"
        fi
        buildah rm "$cnt" &>/dev/null
        return 0
    fi
    # Scrape from Interact
    installPackage wget
    if MCVERSION=$(wget -qO- "$BOARDURL" | grep -o "[0-9][0-9]\.[0-9]\.[0-9]\+" | head -n 1); then
        version_source="webscrape"
    fi

    if ! [[ -v MCVERSION ]]; then
        err "MC version could not be determined. Please check the boardurl: $BOARDURL or specify a version manually using --MCVERSION"
        exit 1
    fi
}


#######################################
# Installs a package using the system package manager
# Arguments:
#   One or more package names
# Options:
#   --nocheck: Do not check if package is already installed
#   --nogpgcheck: Disable GPG checks for RPM based distros
#   --silent, -s: Do not report errors (useful if package is not strictly required and errors are noisy)
#######################################
installPackage() {
    debug "Running: ${FUNCNAME[0]}" "$@"

    declare -a pkg_array install_flags
    declare pkg nocheck silent _return pkg_install_cmd

    if _input=$(getopt -o +s -l nocheck,nogpgcheck,nobest,silent -- "$@"); then
        eval set -- "$_input"
        while true; do
            case "$1" in
                --nocheck)
                    nocheck=1
                    ;;
                --nogpgcheck)
                    if [[ "$ID" =~ ^(fedora|centos)$ ]]; then
                        install_flags+=("--nogpgcheck")
                    elif [[ "$ID" =~ ^opensuse.* ]]; then
                        install_flags+=("--allow-unsigned-rpm")
                    fi
                    ;;
                --nobest)
                    if [[ "$ID" =~ ^(fedora|centos)$ ]]; then
                        install_flags+=("--nobest")
                    fi
                    ;;
                --silent|-s)
                    silent=1
                    ;;
                --)
                    shift
                    break
                    ;;
            esac
            shift
        done
    else
        err "Incorrect options provided"
        exit 1
    fi

    # Aliases
    if [[ "$ID" =~ ^(debian|ubuntu|linuxmint|neon)$ ]]; then
        declare -A PKG_ALIASES
        PKG_ALIASES["xorg-x11-utils"]="xorg-x11"
        PKG_ALIASES["rpm-build"]="rpm"
        PKG_ALIASES["createrepo_c"]="createrepo"
        PKG_ALIASES["tigervnc-server"]="tigervnc-standalone-server"
    fi

    for pkg in "$@"; do
        # Check for alias
        if [[ ! -v nocheck && -v PKG_ALIASES[$pkg] ]]; then
            pkg=${PKG_ALIASES[$pkg]}
        fi
        # Check if already installed
        if (( nocheck )) || ([[ ! -x $(command -v $pkg) ]] \
        && ! pkg_query "$pkg" &>/dev/null); then
            pkg_array+=("$pkg")
        fi
    done

    # Install packages from package array
    if [[ ${#pkg_array[@]} -ge 1 ]]; then
        pkg_install_cmd="pkg_install ${install_flags[*]} ${pkg_array[*]}"
        debug "$pkg_install_cmd" || pkg_install_cmd+=" &>/dev/null"
        if ! eval "$pkg_install_cmd" && (( silent )); then       
            err "Failed to install ${pkg_array[*]}. Attempting to continue..."
        fi

    fi
}


#######################################
# Add the JRiver repository files
#######################################
addRepo() {
    debug "Running: ${FUNCNAME[0]}"

    if [[ "$ID" =~ ^(fedora|centos)$ ]]; then
        bash_cmd 'cat <<- EOF > /etc/yum.repos.d/jriver.repo
			[jriver]
			name=JRiver Media Center repo by BryanC
			baseurl=https://repos.bryanroessler.com/jriver
			gpgcheck=0
		EOF'
    elif [[ "$ID" =~ ^(debian|ubuntu|linuxmint|neon)$ ]]; then
        # MVERSION depends on $BASE unless --mcversion is passed
        installPackage wget
        wget -q "http://dist.jriver.com/mediacenter@jriver.com.gpg.key" -O- | sudo apt-key add - &>/dev/null
        sudo wget "http://dist.jriver.com/latest/mediacenter/mediacenter$MVERSION.list" -O "/etc/apt/sources.list.d/mediacenter$MVERSION.list" &>/dev/null
    elif [[ "$ID" =~ ^opensuse.* ]]; then
        sudo zypper addrepo --no-gpgcheck "https://repos.bryanroessler.com/jriver" jriver &>/dev/null
    fi
}


#######################################
# Installs JRiver Media Center from a repository
#######################################
installMCFromRepo() {
    debug "Running: ${FUNCNAME[0]}"

    echo "Installing JRiver Media Center $MCVERSION from repository."
    echo "Future updates will be handled by your package manager."

    if ! debug; then
        echo "This may take a few minutes to complete."
        echo "Use --debug for verbose output."
    fi

    addRepo

    # Update package list
    debug "$pkg_update_cmd" || pkg_update_cmd+=" &>/dev/null"
    if ! eval "$pkg_update_cmd"; then
        err "Package update failed!"
        exit 1
    fi

    pkg_install_cmd="installPackage --nocheck --nogpgcheck $MCRPM"
    debug "$pkg_install_cmd" || pkg_install_cmd+=" &>/dev/null"
    eval "$pkg_install_cmd"
}


#######################################
# Acquire the source DEB package from JRiver's servers
#######################################
acquireDeb() {
    debug "Running: ${FUNCNAME[0]}"

    declare -g MCDEB="$OUTPUTDIR/SOURCES/MediaCenter-$MCVERSION-amd64.deb"

    # If necessary, create SOURCES dir
    [[ ! -d "$OUTPUTDIR/SOURCES" ]] && mkdir -p "$OUTPUTDIR/SOURCES"

    # If deb file already exists, skip download
    if [[ -f "$MCDEB" ]]; then
        echo "Using local DEB file: $MCDEB"
        return 0
    fi

    if [[ -v BETAPASS ]]; then
        echo "Checking beta repo..."
        if wget -q -O "$MCDEB" \
        "https://files.jriver.com/mediacenter/channels/v$MVERSION/beta/$BETAPASS/MediaCenter-$MCVERSION-amd64.deb"; then
            echo "Found!"
        fi
    elif echo "Checking test repo..." && wget -q -O "$MCDEB" \
    "https://files.jriver.com/mediacenter/test/MediaCenter-$MCVERSION-amd64.deb"; then
        echo "Found!"
    # Else check latest repo
    elif echo "Checking latest repo..." && wget -q -O "$MCDEB" \
    "https://files.jriver.com/mediacenter/channels/v$MVERSION/latest/MediaCenter-$MCVERSION-amd64.deb"; then
        echo "Found!"
    else
        err "Cannot find DEB file."
        exit 1
    fi

    if [[ ! -f "$MCDEB" ]]; then
        err "Downloaded DEB file missing or corrupted."
        exit 1
    fi
}


#######################################
# Creates a SPEC file and builds the RPM from the source DEB using rpmbuild
#######################################
buildRPM() {
    debug "Running: ${FUNCNAME[0]}"

    declare id i rpmbuild_cmd
    declare -a requires recommends
    declare -A dupes
    declare -g MCRPM="$OUTPUTDIR/RPMS/x86_64/MediaCenter-$MCVERSION.x86_64.rpm"

    # skip rebuilding the rpm if it already exists
    if [[ -f "$MCRPM" ]]; then
        echo "$MCRPM already exists. Skipping build step."
        return 0
    fi

    [[ ! -d "$OUTPUTDIR/SPECS" ]] && mkdir -p "$OUTPUTDIR/SPECS"
    
    # Use --target parameter override
    id="${TARGET:-$ID}"

    # Load deb dependencies into array
    IFS=',' read -ra requires <<< "$(dpkg-deb -f "$MCDEB" Depends)"
    IFS=',' read -ra recommends <<< "$(dpkg-deb -f "$MCDEB" Recommends)"

    # Clean up formatting
    requires=("${requires[@]%%|*}")
    requires=("${requires[@]/?:/}")
    requires=("${requires[@]# }")
    requires=("${requires[@]% }")
    requires=("${requires[@]//\(/}")
    requires=("${requires[@]//)/}")
    recommends=("${recommends[@]%%|*}")
    recommends=("${recommends[@]/?:/}")
    recommends=("${recommends[@]# }")
    recommends=("${recommends[@]% }")
    recommends=("${recommends[@]//\(/}")
    recommends=("${recommends[@]//)/}")

    # Translate package names
    case "$id" in
        fedora|centos)
            requires=("${requires[@]/libc6/glibc}")
            requires=("${requires[@]/libasound2/alsa-lib}")
            requires=("${requires[@]/libuuid1/libuuid}")
            requires=("${requires[@]/libx11-6/libX11}")
            requires=("${requires[@]/libxext6/libXext}")
            requires=("${requires[@]/libxcb1/libxcb}")
            requires=("${requires[@]/libxdmcp6/libXdmcp}")
            requires=("${requires[@]/libstdc++6/libstdc++}")
            requires=("${requires[@]/libgtk-3-0/gtk3}")
            requires=("${requires[@]/libgl1/mesa-libGL}")
            requires=("${requires[@]/libpango-1.0-0/pango}")
            requires=("${requires[@]/libpangoft2-1.0-0/pango}")
            requires=("${requires[@]/libpangox-1.0-0/pango}")
            requires=("${requires[@]/libpangoxft-1.0-0/pango}")
            requires=("${requires[@]/libnss3/nss}")
            requires=("${requires[@]/libnspr4/nspr}")
            requires=("${requires[@]/libgomp1/libgomp}")
            requires=("${requires[@]/libfribidi0/fribidi}")
            requires=("${requires[@]/libfontconfig1/fontconfig}")
            requires=("${requires[@]/libfreetype6/freetype}")
            requires=("${requires[@]/libharfbuzz0b/harfbuzz}")
            requires=("${requires[@]/libgbm1/mesa-libgbm}")
            requires=("${requires[@]/libva2/libva}")
            requires=("${requires[@]/libepoxy0/libepoxy}")
            requires=("${requires[@]/liblcms2-2/lcms2}")
            requires=("${requires[@]/libvulkan1/vulkan-loader}")
            requires=("${requires[@]/libepoxy0/libepoxy}")
            ;;
        opensuse*)
            requires=("${requires[@]/libc6/glibc}")
            requires=("${requires[@]/libasound2/alsa-lib}")
            requires=("${requires[@]/libx11-6/libX11-6}")
            requires=("${requires[@]/libxext6/libXext6}")
            requires=("${requires[@]/libxdmcp6/libXdmcp6}")
            requires=("${requires[@]/libgtk-3-0/gtk3}")
            requires=("${requires[@]/libgl1/Mesa-libGL1}")
            requires=("${requires[@]/libpango-1.0-0/pango}")
            requires=("${requires[@]/libpangoft2-1.0-0/pango}")
            requires=("${requires[@]/libpangox-1.0-0/pango}")
            requires=("${requires[@]/libpangoxft-1.0-0/pango}")
            requires=("${requires[@]/libnss3/mozilla-nss}")
            requires=("${requires[@]/libnspr4/mozilla-nspr}")
            requires=("${requires[@]/libfribidi0/fribidi}")
            requires=("${requires[@]/libfontconfig1/fontconfig}")
            requires=("${requires[@]/libfreetype6*/freetype}") # Remove minimum version specifier
            requires=("${requires[@]/libharfbuzz0b/libharfbuzz0}")
            for i in "${!requires[@]}"; do
                [[ "${requires[$i]}" == "mesa-vulkan-drivers" ]] && unset -v 'requires[i]'
            done
            recommends+=("libvulkan_intel")
            recommends+=("libvulkan_radeon")
            ;;
    esac

    # Remove duplicates
    for i in "${requires[@]}"; do
        if [[ ! -v dupes[${i%% *}] ]]; then
            tmp+=("$i")
        fi
        dupes["${i%% *}"]=1
    done
    requires=("${tmp[@]}")

    # Convert array to newline delim'd string (for heredoc)
    printf -v requires "Requires: %s\n" "${requires[@]}"
    printf -v recommends "Recommends: %s\n" "${recommends[@]}"
    # Strip last newline
    requires="${requires%?}" 
    recommends="${recommends%?}"

	if (( COMPAT_SWITCH )); then
		# Strip minimum versions
		requires=$(echo "$requires" | awk -F" " 'NF == 4 {print $1 " " $2} NF != 4 {print $0}')
	fi

    # Create spec file
    cat <<- EOF > "$OUTPUTDIR/SPECS/mediacenter.spec"
		Name:    MediaCenter
		Version: $MCVERSION
		Release: 1
		Summary: JRiver Media Center
		Group:   Applications/Media
		Source0: http://files.jriver.com/mediacenter/channels/v$MVERSION/latest/MediaCenter-$MCVERSION-amd64.deb
		BuildArch: x86_64
		%define _rpmfilename %%{ARCH}/%%{NAME}-%%{version}.%%{ARCH}.rpm

		AutoReq:  0

		$requires
		$recommends

		Provides: mediacenter$MVERSION

		License: Copyright 1998-2022, JRiver, Inc.  All rights reserved.  Protected by U.S. patents #7076468 and #7062468
		URL: http://www.jriver.com/

		%define __provides_exclude_from ^%{_libdir}/jriver/.*/.*\\.so.*$

		%description
		Media Center is more than a world class player.

		%global __os_install_post %{nil}
		%prep

		%build

		%install
		dpkg -x %{S:0} %{buildroot}

		%post -p /sbin/ldconfig
		%postun -p /sbin/ldconfig

		%files
		%{_bindir}/mediacenter$MVERSION
		%{_libdir}/jriver
		%{_datadir}
		%exclude %{_datadir}/applications/media_center_packageinstaller_$MVERSION.desktop
		/etc/security/limits.d/*
	EOF

    # Run rpmbuild
    echo "Building version $MCVERSION, please wait..."
    rpmbuild_cmd="rpmbuild --define=\"%_topdir $OUTPUTDIR\" --define=\"%_libdir /usr/lib\" -bb $OUTPUTDIR/SPECS/mediacenter.spec"
    debug "$rpmbuild_cmd" || rpmbuild_cmd+=" &>/dev/null"
    if eval "$rpmbuild_cmd" && [[ -f "$MCRPM" ]] ; then
        echo "Build successful. The RPM file is located at: $MCRPM"
    else
        err "Build failed."
        # For automation, let's remove the source DEB and reaquire it on next run 
        # after failure in case it is corrupted or buggy
        [[ -f "$MCDEB" ]] && echo "Removing source DEB" && rm -f "$MCDEB"
        exit 1
    fi
}


#######################################
# Copy the RPM to createrepo-webroot and runs createrepo as the createrepo-user
#######################################
runCreaterepo() {
    debug "Running: ${FUNCNAME[0]}"

    declare cr_cmd cr_cp_cmd cr_mkdir_cmd cr_chown_cmd

    installPackage createrepo_c

    # if [[ "$CREATEREPO_USER" != "$USER" ]]



    # If the webroot does not exist, create it
    if [[ ! -d "$CREATEREPO_WEBROOT" ]]; then
        #cr_mkdir_cmd="sudo -u $CREATEREPO_USER mkdir -p $CREATEREPO_WEBROOT"
        #debug "$cr_mkdir_cmd" || cr_mkdir_cmd+=" &>/dev/null"
        #if ! eval "$cr_mkdir_cmd"; then
            cr_mkdir_cmd="mkdir_cmd $CREATEREPO_WEBROOT"
            debug "$cr_mkdir_cmd" || cr_mkdir_cmd+=" &>/dev/null"
            cr_chown_cmd="chown_cmd $CREATEREPO_USER $CREATEREPO_WEBROOT"
            debug "$cr_chown_cmd" || cr_chown_cmd+=" &>/dev/null"
            if ! ( eval "$cr_mkdir_cmd" && eval "$cr_chown_cmd" ); then
                err "Could not create the createrepo-webroot path!"
                err "Make sure that the createrepo-webroot is writeable by createrepo-user: $CREATEREPO_USER"
                return 1
            fi
        #fi
    fi

    # Copy built rpms to webroot
    #cr_cp_cmd="sudo -u $CREATEREPO_USER cp -n -f $MCRPM $CREATEREPO_WEBROOT"
    #cr_chown_cmd="sudo -u $CREATEREPO_USER chown -R $CREATEREPO_USER:$CREATEREPO_USER $CREATEREPO_WEBROOT"
    #debug "$cr_cp_cmd && $cr_chown_cmd" || cr_cp_cmd+=" &>/dev/null" cr_chown_cmd+=" &>/dev/null"
    #if ! ( exec "$cr_cp_cmd" && exec "$cr_chown_cmd" ); then
        cr_cp_cmd="cp_cmd $MCRPM $CREATEREPO_WEBROOT"
        cr_chown_cmd="chown_cmd $CREATEREPO_USER $CREATEREPO_WEBROOT"
        debug "$cr_cp_cmd" || cr_cp_cmd+=" &>/dev/null"
        debug "$cr_chown_cmd" || cr_cp_cmd+=" &>/dev/null"
        if ! (eval "$cr_cp_cmd" && eval "$cr_chown_cmd"); then
            err "Could not copy $MCRPM to $CREATEREPO_WEBROOT"
            #err "Is the createrepo-webroot $CREATEREPO_WEBROOT writeable by createrepo-user: $CREATEREPO_USER?"
            return 1
        fi
    #fi

    # Run createrepo
    cr_cmd="sudo -u $CREATEREPO_USER createrepo -q"
    [[ -d "$CREATEREPO_WEBROOT/repodata" ]] && cr_cmd+=" --update"
    debug "$cr_cmd $CREATEREPO_WEBROOT" || cr_cmd+=" &>/dev/null"
    if ! eval "$cr_cmd $CREATEREPO_WEBROOT"; then
        cr_cmd="sudo createrepo -q"
        [[ -d "$CREATEREPO_WEBROOT/repodata" ]] && cr_cmd+=" --update"
        debug "$cr_cmd $CREATEREPO_WEBROOT" || cr_cmd+=" &>/dev/null"
        if ! eval "$cr_cmd $CREATEREPO_WEBROOT"; then
            err "Update repo failed"
            return 1
        fi
    fi

    echo "Successfully updated repo"
    return 0
}


#######################################
# Symlink certificates where JRiver Media Center expects them to be on Fedora/CentOS
#######################################
symlinkCerts() {
    debug "Running: ${FUNCNAME[0]}"

    if [[ ! -f /etc/ssl/certs/ca-certificates.crt &&
    -f /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem ]]; then
        if ! ln_cmd /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem /etc/ssl/certs/ca-certificates.crt; then
            err "Symlinking certificates failed"
            return 1
        fi
    fi
}


#######################################
# Automatically restore the mjr license file if it is found next to 
# installJRMC or RESTOREFILE is set
#######################################
restoreLicense() {
    debug "Running: ${FUNCNAME[0]}"

    declare _mjr

    # Allow user to put the mjr file next to installJRMC
    if [[ ! -v RESTOREFILE ]]; then
        for _mjr in "$PWD"/*.mjr; do
            [[ $_mjr -nt $RESTOREFILE ]] && RESTOREFILE="$_mjr"
        done
    fi

    # Restore license
    if [[ -f "$RESTOREFILE" ]]; then
        if ! "mediacenter$MVERSION" /RestoreFromFile "$RESTOREFILE"; then
            err "Automatic license restore failed"
            return 1
        fi
    fi
}


#######################################
# Opens ports using the system firewall tool
# Arguments
#   Pre-defined service to enable
#######################################
openFirewall() {
    debug "Running: ${FUNCNAME[0]}" "$@"

    # Create OS-specific port rules based on argument (service) name
    declare -a _f_ports # for firewall-cmd
    declare _u_ports # for ufw
    if [[ "$1" == "jriver" ]]; then
        _f_ports=("52100-52200/tcp" "1900/udp")
        _u_ports="52100:52200/tcp|1900/udp"
    elif [[ "$1" =~ ^(jriver-x11vnc|jriver-xvnc)$ ]]; then
        _f_ports=("$_port/tcp" "1900/udp")
        _u_ports="$_port/tcp|1900/udp"
    fi

    # Open the ports
    if [[ "$ID" =~ ^(fedora|centos|opensuse.*)$ ]]; then
        installPackage firewalld
        if ! firewall_cmd --get-services | grep -q "$1"; then
            firewall_cmd --permanent --new-service="$1" &>/dev/null
            firewall_cmd --permanent --service="$1" --set-description="$1 installed by installJRMC" &>/dev/null
            firewall_cmd --permanent --service="$1" --set-short="$1" &>/dev/null
            for _f_port in "${_f_ports[@]}"; do
                firewall_cmd --permanent --service="$1" --add-port="$_f_port" &>/dev/null
            done
            firewall_cmd --add-service "$1" --permanent &>/dev/null
            firewall_cmd --reload &>/dev/null
        fi
    elif [[ "$ID" =~ ^(debian|ubuntu|linuxmin|neon)$ ]]; then
        # Debian ufw package state is broken on fresh installations
        installPackage ufw
        if [[ ! -f "/etc/ufw/applications.d/$1" ]]; then
            bash_cmd "cat <<- EOF > /etc/ufw/applications.d/$1
				[$1]
				title=$1
				description=$1 installed by installJRMC
				ports=$_u_ports
			EOF"
        fi
        firewall_cmd app update "$1"
        firewall_cmd allow "$1" &>/dev/null
    fi

    # shellcheck disable=SC2181 # More concise
    if [[ $? -ne 0 ]]; then
        err "Firewall ports could not be opened"
        return 1
    fi
}


#######################################
# Create the x11vnc password file
#######################################
setX11VNCPass() {
    debug "Running: ${FUNCNAME[0]}"

    _vncpassfile="$HOME/.vnc/jrmc_passwd"

    [[ ! -d "${_vncpassfile%/*}" ]] && mkdir -p "${_vncpassfile%/*}"

    if [[ -f "$_vncpassfile" ]]; then
        if [[ ! -v VNCPASS ]]; then
            err "Refusing to overwrite existing $_vncpassfile with an empty password"
            err "Remove existing $_vncpassfile or set --vncpass to use an empty password"
            exit 1
        else
            rm -f "$_vncpassfile"
        fi
    fi

    if [[ -v VNCPASS ]]; then
        if ! x11vnc -storepasswd "$VNCPASS" "$_vncpassfile"; then
            err "Could not create VNC password file"
            return 1
        fi
    else
        _novncauth="true"
    fi
}


#######################################
# Create the Xvnc password file
#######################################
setVNCPass() {
    debug "Running: ${FUNCNAME[0]}"

    declare _vncpassfile="$HOME/.vnc/jrmc_passwd"

    [[ ! -d "${_vncpassfile%/*}" ]] && mkdir -p "${_vncpassfile%/*}"

    if [[ -f "$_vncpassfile" ]]; then
        if [[ ! -v VNCPASS ]]; then
            err "Refusing to overwrite existing $_vncpassfile with an empty password"
            err "Remove existing $_vncpassfile or set --vncpass to use an empty password"
            exit 1
        else
            rm -f "$_vncpassfile"
        fi
    fi

    if [[ -v VNCPASS ]]; then
        if ! echo "$VNCPASS" | vncpasswd -f > "$_vncpassfile"; then
            err "Could not create VNC password file"
            return 1
        fi
    else
        _novncauth="true"
    fi
}


#######################################
# Set display and port variables
#######################################
setDisplay() {
    debug "Running: ${FUNCNAME[0]}"

    declare -g DISPLAY DISPLAYNUM NEXT_DISPLAY NEXT_DISPLAYNUM

    # Check USER_DISPLAY, else environment DISPLAY, else set to :0 by default
    DISPLAY="${USER_DISPLAY:-${DISPLAY:-0}}"
    DISPLAYNUM="${DISPLAY#*:}" # strip prefix
    DISPLAYNUM="${DISPLAYNUM%%.*}" # strip suffix
    NEXT_DISPLAYNUM=$(( DISPLAYNUM + 1 ))
    NEXT_DISPLAY=":$NEXT_DISPLAYNUM"
}


#######################################
# Create associated service variables based on service name
#######################################
setServiceVars() {
    debug "Running: ${FUNCNAME[0]}"

    declare -g SERVICE_NAME SERVICE_FNAME TIMER_NAME TIMER_FNAME USER_STRING

    declare service_system_dir="/usr/lib/systemd/system"
    declare service_user_dir="$USER_HOME/.config/systemd/user"

    SERVICE_TYPE="${SERVICE_TYPE:-'system'}"

    if [[ "$USER" == "root" && "$SERVICE_TYPE" == "user" ]]; then
        err "Trying to install user service as root"
        err "Use --service-type service and/or execute installJRMC as non-root user"
        return 1
    fi

    if [[ "$SERVICE_TYPE" == "system" ]]; then # i.e. systemd system service
        service_dir="$service_system_dir"
        systemctl_reload_cmd(){ sudo systemctl daemon-reload; }
        systemctl_enable_cmd(){ sudo systemctl enable --now "$@"; }
        systemctl_disable_cmd(){ sudo systemctl disable --now "$@"; }
    elif [[ "$SERVICE_TYPE" == "user" ]]; then # i.e. systemd user service
        service_dir="$service_user_dir"
        systemctl_reload_cmd(){ systemctl --user daemon-reload; }
        systemctl_enable_cmd(){ systemctl --user enable --now "$@"; }
        systemctl_disable_cmd(){ systemctl --user disable --now "$@"; }
    fi

    [[ ! -d "$service_dir" ]] && mkdir_cmd "$service_dir"

    if [[ "$USER" == "root" || "$SERVICE_TYPE" == "user" ]]; then
        SERVICE_NAME="${1}.service"
        TIMER_NAME="${1}.timer"
        SERVICE_FNAME="$service_dir/${SERVICE_NAME}"
        TIMER_FNAME="$service_dir/${TIMER_NAME}"
        USER_STRING=""
    else
        SERVICE_FNAME="$service_dir/${1}@.service"
        TIMER_FNAME="$service_dir/${1}@.timer"
        SERVICE_NAME="${1}@$USER.service"
        TIMER_NAME="${1}@$USER.timer"
        USER_STRING="User=%I"
    fi
}


#######################################
# Starts and enables (at startup) a JRiver Media Center service
# Arguments:
#   Passes arguments as startup options to /usr/bin/mediacenter??
#######################################
service_jriver-mediacenter() {
    debug "Running: ${FUNCNAME[0]}"

    bash_cmd "cat <<- EOF > $SERVICE_FNAME
		[Unit]
		Description=JRiver Media Center $MVERSION
		After=graphical.target

		[Service]
		$USER_STRING
		Type=simple
		Environment=DISPLAY=$DISPLAY
		Environment=XAUTHORITY=$XAUTHORITY
		ExecStart=/usr/bin/mediacenter$MVERSION $*
		Restart=always
		RestartSec=10
		KillSignal=SIGHUP
		TimeoutStopSec=30

		[Install]
		WantedBy=graphical.target
	EOF"

    systemctl_reload &&
    systemctl_enable "$SERVICE_NAME" &&
    openFirewall "jriver"
}


#######################################
# Starts and enables (at startup) a JRiver Media Server service
#######################################
service_jriver-mediaserver() {
    debug "Running: ${FUNCNAME[0]}"

    service_jriver-mediacenter "/MediaServer"
}


#######################################
# Starts and enables (at startup) JRiver Media Center in a new Xvnc session
#######################################
service_jriver-xvnc() {
    debug "Running: ${FUNCNAME[0]}"

    declare start_cmd
    declare port=$(( NEXT_DISPLAYNUM + 5900 ))

    installPackage tigervnc-server

    setVNCPass

    if [[ -v _novncauth ]]; then
        start_cmd="/usr/bin/vncserver $NEXT_DISPLAY -geometry 1440x900 -alwaysshared -name jriver$NEXT_DISPLAY -SecurityTypes None -autokill -xstartup /usr/bin/mediacenter$MVERSION"
    else
        start_cmd="/usr/bin/vncserver $NEXT_DISPLAY -geometry 1440x900 -alwaysshared -rfbauth $HOME/.vnc/jrmc_passwd -autokill -xstartup /usr/bin/mediacenter$MVERSION"
    fi

    bash_cmd "cat <<- EOF > $SERVICE_FNAME
		[Unit]
		Description=Remote desktop service (VNC)
		After=syslog.target network.target

		[Service]
		Type=simple
		$USER_STRING
		ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill $NEXT_DISPLAY &>/dev/null || :'
		ExecStart=$start_cmd
		ExecStop=/usr/bin/vncserver -kill $NEXT_DISPLAY
		Restart=always

		[Install]
		WantedBy=default.target
	EOF"

    systemctl_reload &&
    systemctl_enable "$SERVICE_NAME" &&
    echo "Xvnc running on localhost:$port" &&
    openFirewall "jriver-xvnc" &&
    openFirewall "jriver"
}


#######################################
# Starts and enables (at startup) JRiver Media Server and x11vnc sharing the local desktop
#######################################
service_jriver-x11vnc() {
    debug "Running: ${FUNCNAME[0]}"

    declare start_cmd
    declare port=$(( DISPLAYNUM + 5900 ))

    installPackage x11vnc

    setX11VNCPass

    # Get current desktop resolution
    # TODO: may need to break this out into its own function and get smarter at identifying multi-monitors
    # _getResolution() {
    #     debug "Running: ${FUNCNAME[0]}"
    #     installPackage xorg-x11-utils
    #     _res=$(xdpyinfo | grep dimensions | awk '{print $2}')
    # }
    # _getResolution

    if [[ -v _novncauth ]]; then
        start_cmd="/usr/bin/x11vnc -display $DISPLAY -noscr -auth guess -forever -bg -nopw"
    else
        start_cmd="/usr/bin/x11vnc -display $DISPLAY -noscr -auth guess -forever -bg -rfbauth $HOME/.vnc/jrmc_passwd"
    fi

    bash_cmd "cat <<-EOF > $SERVICE_FNAME
		[Unit]
		Description=x11vnc
		After=multi.service

		[Service]
		$USER_STRING
		Type=forking
		Environment=DISPLAY=$DISPLAY
		ExecStart=$start_cmd
		Restart=always
		RestartSec=10

		[Install]
		WantedBy=default.target
	EOF"

    systemctl_reload &&
    systemctl_enable "$SERVICE_NAME" &&
    echo "x11vnc running on localhost:$port" &&
    openFirewall "jriver-x11vnc"
}


#######################################
# Starts and enables (at startup) an hourly service to build the latest version of JRiver Media
# Center RPM from the source DEB and create/update an RPM repository
#######################################
service_jriver-createrepo() {
    debug "Running: ${FUNCNAME[0]}"

    declare id="${TARGET:-$ID}"

    bash_cmd "cat <<-EOF > $SERVICE_FNAME
		[Unit]
		Description=Builds JRiver Media Center RPM file, moves it to the repo dir, and runs createrepo

		[Service]
		$USER_STRING
		ExecStart=$PWD/installJRMC --target $id --outputdir $OUTPUTDIR --createrepo --createrepo-webroot $CREATEREPO_WEBROOT --createrepo-user $CREATEREPO_USER

		[Install]
		WantedBy=default.target
	EOF"

    bash_cmd "cat <<-EOF > $TIMER_FNAME
		[Unit]
		Description=Run JRiver MC rpmbuild hourly

		[Timer]
		OnCalendar=hourly
		Persistent=true

		[Install]
		WantedBy=timers.target
	EOF"

    systemctl_reload &&
    systemctl_enable "$TIMER_NAME"
}


#######################################
# CONTAINERS
#######################################
# container_jriver-createrepo() {
#     :
# }


# container_jriver-xvnc() {
#     :
# }


# container_jriver-mediacenter() {

#     installPackage buildah podman

#     # Eventually try to switch to Debian
#     # if ! CNT=$(buildah from debian:$BASE); then
#     #     echo "Bad base image for container $CNAME, skipping"
#     #     continue
#     # fi

#     if ! CNT=$(buildah from jlesage/baseimage-gui:debian-10-v3.5.7); then
#         echo "Bad base image for container $CNAME, skipping"
#         continue
#     fi

#     buildah run "$CNT" add-pkg gnupg2 libxss1 wmctrl xdotool ca-certificates inotify-tools libgbm1 ffmpeg


#     # #BASEIMAGE=jlesage/baseimage-gui:debian-10-v3.5.7
#     # JRIVER_RELEASE=28
#     # JRIVER_TAG=stable
#     # ARCH=amd64
#     # REBUILD_MIN=22
#     # REBUILD_MAX=120

#     # # JRiver Version tag (latest, stable or beta)
#     # ARG jriver_tag

#     # # JRiver Release Version (25, 26 etc.)
#     # ARG jriver_release

#     # # Image Version of the build
#     # ARG image_version

#     # # .deb download URL, if set to "repository" the JRiver repository will be used
#     # ARG deb_url

#     # RUN add-pkg gnupg2 libxss1 wmctrl xdotool ca-certificates inotify-tools libgbm1 ffmpeg

#     # Install JRiver
#     RUN \
#         add-pkg --virtual build-dependencies wget &&
#         # Install from Repository
#         if [ "${deb_url}" = "repository" ]; then \
#             echo "Installing JRiver from repository ${jriver_release}:${jriver_tag}" &&
#             wget -q "http://dist.jriver.com/mediacenter@jriver.com.gpg.key" -O- | apt-key add - &&
#             wget http://dist.jriver.com/${jriver_tag}/mediacenter/mediacenter${jriver_release}.list -O /etc/apt/sources.list.d/mediacenter${jriver_release}.list &&
#             apt-get update &&
#             add-pkg mediacenter${jriver_release}; \
#         # Install from .deb URL
#         else \
#             echo "Installing JRiver from URL: ${deb_url}" &&
#             wget -q -O "jrivermc.deb" ${deb_url} &&
#             add-pkg "./jrivermc.deb"; \
#         fi &&
#         # Cleanup
#         del-pkg build-dependencies &&
#         rm -rf /tmp/* /tmp/.[!.]*

#     # Add rootfs
#     COPY rootfs/ /

#     VOLUME ["/config"]

#     # Application Icon
#     RUN \
#         APP_ICON_URL=https://gitlab.com/shiomax/jrivermc-docker/raw/master/assets/Application.png &&
#         install_app_icon.sh "$APP_ICON_URL"

#     # Various configuration vars
#     ENV KEEP_APP_RUNNING=1 \
#         DISPLAY_WIDTH=1280 \
#         DISPLAY_HEIGHT=768 \
#         APP_NAME="JRiver MediaCenter ${jriver_release}" \
#         MAXIMIZE_POPUPS=0 \
#         S6_KILL_GRACETIME=8000

#     # Modify startapp.sh and rc.xml with JRiver version
#     RUN sed-patch s/%%MC_VERSION%%/${jriver_release}/g \
#             /startapp.sh &&
#         sed-patch s/%%MC_VERSION%%/${jriver_release}/g \
#             /etc/xdg/openbox/rc.xml

#     EXPOSE 5800 5900 52100 52101 52199 1900/udp

#     # Metadata.
#     LABEL \
#         org.label-schema.name="jrivermc${jriver_release}" \
#         org.label-schema.description="Docker image for JRiver Media Center ${jriver_release}." \
#         org.label-schema.version="${image_version}" \
#         org.label-schema.vcs-url="https://gitlab.com/shiomax/jrivermc-docker" \
#         org.label-schema.schema-version="1.0"

#     installPackage buildah podman
#     cnt=$(buildah from docker.io/jlesage/baseimage-gui:debian-10)
#     podman_create_cmd=("podman" "create" "--name" "$CNAME")
#     buildah_config_cmd=("buildah" "config" \
#         "--author" "bryanroessler@gmail.com" \
#         "--label" "maintainer=$MAINTAINER" \
#         "--env" "TZ=$TZ" \
#         "--workingdir" "/app" \
#         "--cmd" "mediacenter$MVERSION")

#     mkcdirs() {
#         declare dir
#         for dir in "$@"; do
#             if [[ ! -d "$dir" ]]; then 
#                 if ! mkdir -p "$dir"; then
#                     err "Could not create directory $dir, check your permissions"
#                 fi
#             fi
#             if ! chcon -t container_file_t -R "$dir"; then
#                 err "Could not set container_file_t attribute for $dir, check your permissions"
#             fi
#         done
#     }

#     mkcdirs "$HOME/.jriver"

#     podman_create_cmd+=("-v" "$HOME/.jriver:/root/.jriver")
#     podman_create_cmd+=("-v" "$DOWNLOAD_ROOT:/downloads:z")
#     podman_create_cmd+=("-v" "$MONITOR_ROOT/nzbs:/nzbs")
#     podman_create_cmd+=("-p" "${CONTAINER[HOST_PORT]}:${CONTAINER[CONTAINER_PORT]}")

#     brc() { buildah run "$1" "${@:2}" || return 1; }

#     brc add-pkg gnupg2 libxss1 wmctrl xdotool ca-certificates inotify-tools libgbm1

#     brc add-pkg --virtual .build-deps wget

#     brc sh -s <<- EOF
# 		wget -q "http://dist.jriver.com/mediacenter@jriver.com.gpg.key" -O- | apt-key add - &>/dev/null
# 	EOF

#     brc wget "http://dist.jriver.com/latest/mediacenter/mediacenter$MVERSION.list" -O "/etc/apt/sources.list.d/mediacenter$MVERSION.list"

#     brc apt-get update -y -q0

#     brc add-pkg "mediacenter$MVERSION"

#     brc del-pkg .build-deps
# }

uninstall() {
    debug "Running: ${FUNCNAME[0]}"

    declare service unit f

    if ! askOk "Do you really want to uninstall JRiver Media Center"; then
        echo "Cancelling uninstall..."
        exit 0
    fi

    debug "Stopping and removing all associated Media Center services"
    for service in $(compgen -A "function" "service"); do
        service="${service##service_}"
        if ! setServiceVars "$service"; then
            continue
        fi
        for unit in "$SERVICE_NAME" "$TIMER_NAME"; do
            if systemctl is-active -q "$unit" &>/dev/null || systemctl is-enabled -q "$unit" &>/dev/null; then
                debug "Disabling $unit"
                systemctl_disable "$unit"
            fi
        done
        for f in "$SERVICE_FNAME" "$TIMER_FNAME"; do
            [[ -f "$f" ]] && debug "Removing $f" && rm_cmd "$f"
        done
        systemctl_reload
    done

    debug "Removing repo files"
    [[ -f "/etc/yum.repos.d/jriver.repo" ]] \
        && rm_cmd "/etc/yum.repos.d/jriver.repo"
    [[ -f "/etc/apt/sources.list.d/jriver.list" ]] \
        && rm_cmd "/etc/apt/sources.list.d/jriver.list"
    if [[ "$ID" =~ ^opensuse.* ]]; then
        sudo zypper rr jriver &>/dev/null
    fi

    debug "Removing firewall rules"
    if [[ -x $(command -v firewall-cmd) ]]; then
        if [[ -v debug ]]; then
            debug "firewall_cmd --permanent --remove-service=jriver"
            firewall_cmd --permanent --remove-service=jriver
            debug "firewall_cmd --permanent --delete-service=jriver"
            firewall_cmd --permanent --delete-service=jriver
            debug "firewall_cmd --reload"
            firewall_cmd --reload
        else
            firewall_cmd --permanent --remove-service=jriver &>/dev/null
            firewall_cmd --permanent --delete-service=jriver &>/dev/null
            firewall_cmd --reload &>/dev/null
        fi
    elif [[ -x $(command -v ufw) ]]; then
        firewall_cmd="firewall_cmd delete allow jriver"
        debug "$firewall_cmd" || firewall_cmd+=" &>/dev/null"
        eval "$firewall_cmd"
        [[ -f "/etc/ufw/applications.d/jriver" ]] \
            && rm_cmd /etc/ufw/applications.d/jriver
    fi

    debug "Uninstalling Media Center package"
    mc_pkg_rm_cmd="pkg_remove $MCRPM"
    debug "$mc_pkg_rm_cmd" || mc_pkg_rm_cmd+=" &>/dev/null"
    if eval "$mc_pkg_rm_cmd"; then 
        echo "JRiver Media Center has been completely uninstalled."
        echo "To remove your library files, run: rm -rf $HOME/.jriver"
        echo "To remove your rpmbuild output files, run: rm -rf $OUTPUTDIR"
        exit 0
    else
        exit $?
    fi
}


tests() {
    # To test on Mint: sudo apt-get install -y spice-vdagent ca-certificates git; export GIT_SSL_NO_VERIFY=1
    exit $?
}


main() {
    debug "Running: ${FUNCNAME[0]}"

    declare service

    init "$@"

    # Uninstall and exit
    if (( UNINSTALL_SWITCH )); then
        uninstall
        exit $?
    fi

    # Install dependency dependencies :-)
    [[ "$ID" == "centos" ]] && installPackage epel-release

    # Install MC using package manager
    if (( REPO_INSTALL_SWITCH )); then
        if [[ "$ID" =~ ^opensuse.*$ ]]; then
            echo "A SUSE repository is not yet available."
            echo "Use --install rpm to build and install a SUSE RPM instead."
            exit 1
        fi
        if installMCFromRepo; then
            echo "JRiver Media Center installed successfully"
        else
            err "JRiver Media Center installation failed"
            exit 1
        fi
        symlinkCerts
        restoreLicense
        openFirewall "jriver"
    fi

    if (( DEB_INSTALL_SWITCH )); then
        acquireDeb
        declare extract_dir && extract_dir="$(mktemp -d)"
        ar x --output "$extract_dir" "$MCDEB"
        tar -xJf "$extract_dir/control.tar.xz" -C "$extract_dir"
        # Remove minimum version specifiers from control file
        sed -i 's/ ([^)]*)//g' "$extract_dir/control"
        tar -C "$extract_dir" \
            --ignore-failed-read \
            -cvJf "control.tar.xz" "control" "postinst"
        ar rcs "$MCDEB.compat" "$extract_dir/debian-binary" "$extract_dir/control.tar.xz" "$extract_dir/data.tar.xz"
        pkg_install_cmd="installPackage --nocheck --nogpgcheck $MCDEB.compat"
        debug "$pkg_install_cmd" || pkg_install_cmd+=" &>/dev/null"
        eval "$pkg_install_cmd"
        rm -rf "$extract_dir"
    fi

    # Build RPM from source deb package
    if (( RPM_BUILD_SWITCH )); then
        installPackage "wget" "dpkg" "rpm-build"
        acquireDeb
        buildRPM
    fi

    # Run createrepo
    if (( CREATEREPO_SWITCH )); then
        runCreaterepo
        exit $?
    fi

    # Install RPM
    if [[ -v INSTALL_TYPE && "$INSTALL_TYPE" == "rpm" ]]; then

        #rpm --upgrade "$MCRPM"        

        if installPackage --nocheck --nogpgcheck "$MCRPM"; then
            echo "JRiver Media Center installed successfully"
        else
            err "JRiver Media Center installation failed"
            exit 1
        fi
        symlinkCerts
        restoreLicense
        openFirewall "jriver"
    fi

    # Install services
    if [[ "${#SERVICES[@]}" -gt 0 ]]; then
        setDisplay
        for service in "${SERVICES[@]}"; do
            if ! setServiceVars "$service"; then
                continue
            fi
            if ! "service_$service"; then
                if [[ $? -eq 127 ]]; then
                    err "Service $service does not exist, check your service name"
                else
                    err "Failed to create service: $service"
                fi
            fi
        done
    fi

    # Install containers
    # for _container in "${CONTAINERS[@]}"; do
    #     if ! "_container_$_container"; then
    #         if [[ $? -eq 127 ]]; then
    #             err "Container $_container does not exist, check your container name"
    #         else
    #             err "Failed to create container: $_container"
    #         fi
    #     fi
    # done
}


main "$@"
