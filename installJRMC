#!/usr/bin/env bash
# shellcheck disable=SC2317
# @file installJRMC
# @brief Install JRiver Media Center and associated services
# @description See installJRMC --help or print_help() below for usage
# Copyright (c) 2021-2025 Bryan C. Roessler
# This software is released under the Apache License.
# https://www.apache.org/licenses/LICENSE-2.0
#
# TODO (v2)
# * Interactive mode
# * Additional containerization (createrepo and rpmbuild)
#
# BUGS
# * No createrepo on Mint
#
# NOTES
# * Be careful with tabs in heredocs
shopt -s extglob

declare -g SCRIPT_VERSION="1.5.0-dev"
declare -g MC_REPO="bullseye" # should match the MC_VERSION
# declare -g MC_REPO="bookworm" # should match the MC_VERSION
declare -g MC_VERSION="33.0.72" # do find all replace
declare -g BOARD_URL="https://yabb.jriver.com/interact/index.php/board,86.0.html" # MC33
# declare -g BOARD_URL="https://yabb.jriver.com/interact/index.php/board,89.0.html" # MC34
declare -gi UPDATE_SWITCH=1 # set to 0 to disable automatic self-update
declare -g SCRIPT_URL="https://git.bryanroessler.com/bryan/installJRMC/raw/master/installJRMC"
# declare -g SCRIPT_URL="https://raw.githubusercontent.com/cryobry/installJRMC/refs/heads/master/installJRMC"
declare -gi DEBUG=${DEBUG:-0} # set default debug and allow DEBUG env override (default: disabled)

# @description Print help text
print_help() {
  debug "Running: ${FUNCNAME[0]}"

  cat <<-EOF
		USAGE:
		  installJRMC [[OPTION] [VALUE]]...

		  If no options (excluding -d or --debug) are provided installJRMC defaults to '--install repo'.

		OPTIONS
		  --install, -i repo|local
		    repo: Install MC from repository, updates are handled by the system package manager
		    local: Build and install MC package locally from official source release
		  --build[=suse|fedora|centos]
		    Build RPM from source DEB but do not install
		    Optionally, specify a target distro for cross-building (ex. --build=suse, note the '=')
		  --compat
		    Build/install MC locally without minimum dependency version requirements
		  --mcversion VERSION
		    Specify the MC version, ex. "$MC_VERSION" or "${MC_VERSION%%.*}" (default: latest)
		  --arch VERSION
		    Specify the MC architecture, ex. "amd64", "arm64", etc (default: host architecture)
		  --mcrepo REPO
		    Specify the MC repository, ex. "bullseye", "bookworm", "noble", etc (default: latest official)
		  --outputdir PATH
		    Generate rpmbuild output in this directory (default: ./output)
		  --restorefile MJR_FILE
		    Restore file location for automatic license registration
		  --betapass PASSWORD
		    Enter beta team password for access to beta builds
		  --service, -s SERVICE
		    See SERVICES section below for a list of possible services to install
		    --service-type user|system
		      Starts services at boot (system) or at user login (user) (default: per service, see SERVICES)
		  --container, -c CONTAINER (TODO: Under construction)
		    See CONTAINERS section below for a list of possible services to install
		  --createrepo[=suse|fedora|centos]
		    Build rpm, copy to webroot, and run createrepo. 
		    Use in conjunction with --build=TARGET for crossbuilding repos
		    Optionally, specify a target distro for non-native repo (ex. --createrepo=fedora, note the '=')
		    --createrepo-webroot PATH
		      Specify the webroot directory to install the repo (default: /var/www/jriver)
		    --createrepo-user USER
		      Specify the web server user if it differs from \$USER
		  --no-update
		    Disable automatic installJRMCself-update
		  --uninstall, -u
		    Uninstall JRiver MC, remove services, containers, and firewall rules (does not remove library files)
		  --yes, -y, --auto
		    Assume yes response to questions
		  --version, -v
		    Print this script version and exit
		  --debug, -d
		    Print debug output
		  --help, -h
		    Print help dialog and exit

		SERVICES
		  jriver-mediaserver (default --service-type=user)
		    Enable and start a mediaserver systemd service (requires an existing X server)
		  jriver-mediacenter (user)
		    Enable and start a mediacenter systemd service (requires an existing X server)
		  jriver-x11vnc (user)
		    Enable and start x11vnc for the local desktop (requires an existing X server)
		    Usually combined with jriver-mediaserver or jriver-mediacenter services
		    --vncpass and --display are optional (see below)
		  jriver-xvnc (system)
		    Enable and start a new Xvnc session running JRiver Media Center
		    --vncpass PASSWORD
		      Set the vnc password for x11vnc/Xvnc access. If no password is set, installJRMC
		      will either use existing password stored in \$HOME/.vnc/jrmc_passwd or use no password
		    --display DISPLAY
		      Display to use for x11vnc/Xvnc (default: The current display (x11vnc) or the
		      current display incremented by 1 (Xvnc))
		  jriver-createrepo (system)
		    Install hourly service to build latest MC RPM and run createrepo

		CONTAINERS (TODO: Under construction)
		  mediacenter-xvnc
		  createrepo
	EOF
}

# @description Parses user input and sets sensible defaults
# @arg $@ User input
parse_input() {
  debug "Running: ${FUNCNAME[0]} $*"
  declare -gi BUILD_SWITCH REPO_INSTALL_SWITCH LOCAL_INSTALL_SWITCH \
    CONTAINER_INSTALL_SWITCH CREATEREPO_SWITCH \
    COMPAT_SWITCH UNINSTALL_SWITCH YES_SWITCH DEBUG=0
  declare -g USER_MC_VERSION USER_MC_RELEASE USER_MC_REPO MJR_FILE \
    BETAPASS SERVICE_TYPE VNCPASS USER_DISPLAY BUILD_TARGET CREATEREPO_TARGET
  local long_opts short_opts input
  long_opts="install:,build::,outputdir:,mcversion:,arch:,mcrepo:,compat,"
  long_opts+="restorefile:,betapass:,"
  long_opts+="service-type:,service:,services:,"
  long_opts+="version,debug,verbose,help,uninstall,yes,auto,no-update,"
  long_opts+="createrepo::,createrepo-webroot:,createrepo-user:,"
  long_opts+="vncpass:,display:,container:"
  short_opts="+i:b::s:c:uyvdh"

  if input=$(getopt -o $short_opts -l $long_opts -- "$@"); then
    eval set -- "$input"
    while true; do
      case $1 in
        --install|-i)
          shift
          case $1 in
            local|rpm|deb) BUILD_SWITCH=1; LOCAL_INSTALL_SWITCH=1 ;;
            repo|remote) REPO_INSTALL_SWITCH=1 ;;
            container) CONTAINER_INSTALL_SWITCH=1 ;;
            *) err "Invalid --install option passed"; exit 1 ;;
          esac
          ;;
        --build|-b) BUILD_SWITCH=1; shift; BUILD_TARGET="$1" ;;
        --outputdir) shift; OUTPUT_DIR="$1" ;;
        --mcversion)
          shift
          if [[ $1 =~ ^[0-9]+\.[0-9]+\.[0-9]+-[0-9]+$ ]]; then
            USER_MC_VERSION="${1%-*}"
            USER_MC_RELEASE="${1#*-}"
          elif [[ $1 =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            USER_MC_VERSION="$1"
          elif [[ $1 =~ ^[0-9][0-9]$ ]]; then
            case $1 in
              33) ;; # use update check to determine latest version
              32) USER_MC_VERSION="32.0.58" ;;
              31) USER_MC_VERSION="31.0.83" ;;
              30) USER_MC_VERSION="30.0.96" ;;
              29) USER_MC_VERSION="29.0.91" ;;
              28) USER_MC_VERSION="28.0.110" ;;
              27) USER_MC_VERSION="27.0.88" ;;
              26) USER_MC_VERSION="26.0.107" ;;
              25) USER_MC_VERSION="25.0.114" ;;
              24) USER_MC_VERSION="24.0.78" ;;
              23) USER_MC_VERSION="23.0.104" ;;
              22) USER_MC_VERSION="22.0.102" ;;
              21) USER_MC_VERSION="21.0.90" ;;
              20) USER_MC_VERSION="20.0.131" ;;
              *) err "Bad --mcversion"; print_help; exit 1 ;;
            esac
          else
            err "Bad --mcversion"; print_help; exit 1
          fi
          ;;
        --arch) shift; echo "Switching arch from $ARCH to $1"; ARCH="$1" ;;
        --mcrepo) shift; USER_MC_REPO="$1" ;;
        --restorefile) shift; MJR_FILE="$1" ;;
        --betapass) shift; BETAPASS="$1" ;;
        --service-type) shift; SERVICE_TYPE="$1" ;;
        --service|-s|--services) shift; SERVICES+=("$1") ;;
        --createrepo) shift; CREATEREPO_TARGET="$1"; BUILD_TARGET="$1"
          BUILD_SWITCH=1; CREATEREPO_SWITCH=1 ;;
        --createrepo-webroot) shift; CREATEREPO_WEBROOT="$1" ;;
        --createrepo-user) shift; CREATEREPO_USER="$1" ;;
        --vncpass) shift; VNCPASS="$1" ;;
        --display) shift; USER_DISPLAY="$1" ;;
        --compat) COMPAT_SWITCH=1; BUILD_SWITCH=1 ;;
        --no-update) UPDATE_SWITCH=0 ;;
        --container|-c) shift; CONTAINERS+=("$1") ;;
        --yes|-y|--auto) YES_SWITCH=1 ;;
        --version|-v) echo "Version: $SCRIPT_VERSION"; exit 0 ;;
        --debug|-d|--verbose) DEBUG=1 ;;
        --help|-h) print_help; exit 0 ;;
        --uninstall|-u) UNINSTALL_SWITCH=1 ;;
        --) shift; break ;;
      esac
      shift
    done
  else
    err "Incorrect option provided, see installJRMC --help"; exit 1
  fi

  # Fallback to default install method in some scenarios
  if ! ((UNINSTALL_SWITCH + BUILD_SWITCH + CREATEREPO_SWITCH + 
    LOCAL_INSTALL_SWITCH + CONTAINER_INSTALL_SWITCH)) &&
    [[ ${#SERVICES[@]} -eq 0 && ${#CONTAINERS[@]} -eq 0 ]]; then
    debug "Automatically using --install=repo"
    REPO_INSTALL_SWITCH=1
  fi

  # Print some warnings for unsupported argument combinations
  if [[ -n $USER_MC_REPO ]] && ((LOCAL_INSTALL_SWITCH)); then
    err "--install=local is not compatible with --mcrepo as only the default ($MC_REPO) DEB is available"
  fi

  if [[ -n $BETA_PASS ]] && ((REPO_INSTALL_SWITCH)); then
    echo "Warning: not all repositories have beta channels"
    echo "If the MC package is unavailable, try using --mcrepo to select another repository"
  fi

  if [[ -n $CONTAINER_INSTALL_SWITCH ]] && ((LOCAL_INSTALL_SWITCH || REPO_INSTALL_SWITCH)); then
    err "Some --install methods are incompatible"
  fi
}

# @description Perform OS detection and generate OS-specific functions
# @see parse_input
init() {
  debug "Running: ${FUNCNAME[0]}"
  declare -g USER
  declare -g SCRIPT_PATH; SCRIPT_PATH=$(readlink -f "${BASH_SOURCE[0]}")
  declare -g SCRIPT_DIR; SCRIPT_DIR=$(readlink -f "$(dirname "${BASH_SOURCE[0]}")")
  declare -g OUTPUT_DIR="$SCRIPT_DIR/output"
  declare -g CREATEREPO_WEBROOT="/var/www/jriver"
  declare -g CREATEREPO_USER="$USER" # can be root
  declare -g ID VERSION_ID ARCH NAME
  declare -g MC_MVERSION MC_RELEASE MC_PKG MC_RPM MC_ROOT
  declare -ga PKG_INSTALL PKG_REMOVE PKG_UPDATE PKG_QUERY
  declare -ga SERVICES CONTAINERS

  # Try to save users from themselves
  if ((EUID == 0)); then
    err "Running as root but attempting to continue"
    ask_ok "Continue as root user?" || exit 1
  fi

  if [[ -n $SUDO_USER ]]; then
    err "Sudo detected, installJRMC should not be run with sudo but attempting to continue"
    ask_ok "Continue as user $SUDO_USER (unsupported and may result in permission issues)?" || exit 1
    USER="${SUDO_USER:-$USER}"
  fi

  parse_input "$@"

  # Run the self-updater if enabled
  ((UPDATE_SWITCH)) && update "$@"

  # Get host information
  [[ -f /etc/os-release ]] && source /etc/os-release

  # Detect architecture and translate to MC convention
  if ARCH=$(uname -m); then
    case $ARCH in
      x86_64) ARCH="amd64" ;;
      aarch64) ARCH="arm64" ;;
    esac
  else
    ARCH="amd64"
    err "Failed to detect host arch, using default: $ARCH"
  fi

  debug "Detected host platform: $ID $VERSION_ID $ARCH"

  # Normalize ID and set host-specific vars
  case $ID in
    debian|arch|fedora|centos) ;;
    rhel|almalinux) ID="centos" ;;
    linuxmint|neon|zorin|*ubuntu*) ID="ubuntu" ;;
    raspbian) ID="debian" ;;
    *suse*)
      ID="suse"
      # Currently there is no remote repository for SUSE
      # installJRMC can easily create one but I'd rather a SUSEian provide it
      # So use local rpmbuild method by default for SUSE
      if ((REPO_INSTALL_SWITCH)); then
        debug "Automatically using --install=local for SUSE"
        REPO_INSTALL_SWITCH=0
        BUILD_SWITCH=1
        LOCAL_INSTALL_SWITCH=1
      fi
      ;;
    *)
      err "Auto-detecting distro, this is unreliable and --compat may be required"
      for cmd in dnf yum apt-get pacman; do
        if command -v "$cmd" &>/dev/null; then
          case "$cmd" in
            dnf) ID="fedora" ;;
            yum) ID="centos"; COMPAT_SWITCH=1 ;;
            apt-get) ID="ubuntu" ;;
            pacman) ID="arch" ;;
          esac
          break
        fi
      done

      if [[ -z $ID ]]; then
        err "OS detection failed!"
        if ask_ok "Continue with manual installation?"; then
          debug "Automatically using --install=local for unknown distro"
          ID="unknown"
          REPO_INSTALL_SWITCH=0
          BUILD_SWITCH=1
          LOCAL_INSTALL_SWITCH=1
        else
          exit 1
        fi
      fi
      ;;
  esac

  # Set default targets
  BUILD_TARGET="${BUILD_TARGET:-$ID}"
  CREATEREPO_TARGET="${CREATEREPO_TARGET:-$ID}"

  # Match the MC repo to the system codename
  if [[ -z $USER_MC_REPO && ($ID == debian || $ID == ubuntu) ]]; then
    MC_REPO=${UBUNTU_CODENAME:-${VERSION_CODENAME:-$MC_REPO}}
  fi

  # Use the correct repo for legacy MC versions
  if [[ -n $USER_MC_VERSION ]]; then
    case ${USER_MC_VERSION%%.*} in # get MVERSION from user input
      2[0-6]) USER_MC_REPO="jessie" ;;
      2[7-9]|30) USER_MC_REPO="buster" ;;
      31) USER_MC_REPO="bullseye" ;;
      # After this point, things get messy with multiple repos for the same MC version
      # Just use the default repo
    esac
  fi

  # Set distro-specific package manager commands for normalized IDs
  case $ID in
    fedora|centos)
      local rpm_mgr
      rpm_mgr=$(command -v dnf &>/dev/null && echo "dnf" || echo "yum")
      PKG_INSTALL=(sudo "$rpm_mgr" install -y)
      PKG_REMOVE=(sudo "$rpm_mgr" remove -y)
      PKG_UPDATE=(sudo "$rpm_mgr" makecache)
      PKG_QUERY=(rpm -q)
      PKG_INSTALL_LOCAL() { install_mc_rhel; }
      ;;
    debian|ubuntu)
      PKG_INSTALL=(sudo apt-get -f install -y -q0)
      PKG_REMOVE=(sudo apt-get remove --auto-remove -y -q0)
      PKG_UPDATE=(sudo apt-get update -y -q0)
      PKG_QUERY=(dpkg -s)
      PKG_INSTALL_LOCAL() { install_mc_deb "$@"; }
      ;;
    suse)
      PKG_INSTALL=(sudo zypper --gpg-auto-import-keys --non-interactive --quiet install --force --force-resolution --replacefiles --no-confirm)
      PKG_REMOVE=(sudo zypper --non-interactive --quiet remove --clean-deps)
      PKG_UPDATE=(sudo zypper --non-interactive --quiet refresh jriver)
      PKG_QUERY=(rpm -q)
      PKG_INSTALL_LOCAL() { install_mc_suse; }
      ;;
    arch)
      PKG_INSTALL=(sudo pacman -Sy --noconfirm)
      PKG_REMOVE=(sudo pacman -Rs --noconfirm)
      PKG_UPDATE=(sudo pacman -Syy)
      PKG_QUERY=(sudo pacman -Qs)
      PKG_INSTALL_LOCAL() { install_mc_arch; }
      ;;
    unknown)
      PKG_INSTALL=(:)
      PKG_REMOVE=(:)
      PKG_UPDATE=(:)
      PKG_QUERY=(:)
      PKG_INSTALL_LOCAL() { install_mc_generic; }
      ;;
  esac

  # Don't check for latest MC version if set by user or using --install=repo only
  if [[ -z $USER_MC_VERSION ]] \
  && ((BUILD_SWITCH || LOCAL_INSTALL_SWITCH || CREATEREPO_SWITCH)); then
    # Retrieves the latest MC version number from the specified MC_REPO
    get_latest_mc_version "${USER_MC_REPO:-$MC_REPO}"
  fi
  
  # Set MC version variables
  MC_REPO="${USER_MC_REPO:-$MC_REPO}"
  MC_VERSION="${USER_MC_VERSION:-$MC_VERSION}"
  MC_RELEASE="${USER_MC_RELEASE:-1}"
  MC_MVERSION="${MC_VERSION%%.*}"
  MC_PKG="mediacenter$MC_MVERSION"
  MC_RPM="$OUTPUT_DIR/RPMS/x86_64/mediacenter$MC_MVERSION-$MC_VERSION-$MC_RELEASE.x86_64.rpm"
  MC_ROOT="/usr/lib/jriver/Media Center $MC_MVERSION"

  if [[ -n $USER_MC_VERSION ]]; then
    # Append explicit package version when user provides --mcversion
    case $ID in
      fedora|centos|suse) MC_PKG+="-$MC_VERSION" ;;
      debian|ubuntu) MC_PKG+="=$MC_VERSION" ;;
    esac
  fi

  debug "Host platform: $ID $VERSION_ID"
  debug "MC repository: $MC_REPO"
}

# @description Determines the latest JRiver MC version using several methods
# @arg $1 string MC repository name
get_latest_mc_version() {
  debug "Running: ${FUNCNAME[0]}" "$*"
  local cnt mc_version_source

  # Use generalized containerized package manager to determine latest MC version
  if install_package --silent buildah \
  && cnt=$(buildah from --quiet alpine:edge 2>/dev/null) \
  && buildah run "$cnt" -- sh -c \
    "apk add apt" &>/dev/null \
  && buildah run "$cnt" -- sh -c \
    "echo 'deb [trusted=no arch=amd64,i386,armhf,arm64] http://dist.jriver.com/latest/mediacenter/ $1 main' > /etc/apt/sources.list 2>&1" &>/dev/null \
  && buildah run "$cnt" -- sh -c \
    "apt update --allow-insecure-repositories &>/dev/null" &>/dev/null \
  && MC_VERSION=$(buildah run "$cnt" -- apt-cache policy mediacenter?? | grep Candidate | awk '{print $2}' | sort -V | tail -n1) &>/dev/null \
  && [[ $MC_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
    mc_version_source="containerized package manager"
    execute buildah rm "$cnt"
  # Fallback to webscrape
  elif MC_VERSION=$(download "$BOARD_URL" | grep -o "[0-9][0-9]\.[0-9]\.[0-9]\+" | head -n 1) \
  && [[ $MC_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
    mc_version_source="webscrape"
  # Fallback to hardcoded value
  else
    mc_version_source="hardcoded"
    err "Warning! Using hardcoded version number"
  fi
  
  echo "Using latest MC version $MC_VERSION from the $MC_REPO repo (determined by $mc_version_source)"
}

# @description Installs a package using the system package manager
# @arg $1 array One or more package names
# @option --no-install-check Do not check if package is already installed
# @option --no-gpg-check Disable GPG checks for RPM based distros
# @option --allow-downgrades Useful for installing specific MC versions
# @option --silent | -s Do not print errors (useful for optional packages)
install_package() {
  debug "Running: ${FUNCNAME[0]}" "$@"
  local -a pkg_array install_flags
  local -A pkg_aliases
  local input pkg _pkg
  local -i no_install_check=0 allow_downgrades=0 silent=0 refresh=0 no_gpg_check=0 reinstall=0
  local long_opts="no-install-check,allow-downgrades,no-gpg-check,refresh,reinstall,silent"

  input=$(getopt -o +s -l "$long_opts" -- "$@") || { err "Incorrect options provided"; exit 1; }
  eval set -- "$input"
  
  while true; do
    case $1 in
      --no-install-check) no_install_check=1 ;;
      --allow-downgrades) allow_downgrades=1 ;;
      --no-gpg-check) no_gpg_check=1 ;;
      --refresh) refresh=1 ;;
      --reinstall) reinstall=1 ;;
      --silent|-s) silent=1 ;;
      --) shift; break ;;
    esac
    shift
  done

  # Define package aliases based on the distribution
  case $ID in
    debian|ubuntu)
      pkg_aliases=(
        [rpm-build]="rpm"
        [createrepo_c]="createrepo"
        [tigervnc-server]="tigervnc-standalone-server"
      ) ;;
    suse)
      pkg_aliases=(
        [buildah]="buildah fuse-overlayfs"
      ) ;;
  esac

  # Filter out already installed packages to create pkg_array
  for pkg in "$@"; do
    if [[ -v pkg_aliases[$pkg] ]]; then
      debug "Aliasing $pkg to ${pkg_aliases[$pkg]}"
      IFS=' ' read -ra pkgs <<< "${pkg_aliases[$pkg]}"
      for _pkg in "${pkgs[@]}"; do
        if ((no_install_check)) \
        || ! { command -v "$_pkg" &>/dev/null \
        || "${PKG_QUERY[@]}" "$_pkg" &>/dev/null; }; then
          pkg_array+=("$_pkg")
        else
          debug "$_pkg is already installed, skipping installation"
        fi
      done
    else
      if ((no_install_check)) \
      || ! { command -v "$pkg" &>/dev/null \
      || "${PKG_QUERY[@]}" "$pkg" &>/dev/null; }; then
        pkg_array+=("$pkg")
      else
        debug "$pkg is already installed, skipping installation"
      fi
    fi
  done

  # Generate installation flags based on the distribution
  case $ID in
    debian|ubuntu)
      ((allow_downgrades)) && install_flags+=(--allow-downgrades)
      ((reinstall)) && install_flags+=(--reinstall) ;;
    fedora|centos)
      ((allow_downgrades)) && install_flags+=(--allowerasing)
      ((no_gpg_check)) && install_flags+=(--nogpgcheck)
      ((refresh)) && install_flags+=(--refresh)
      ;;
    suse)
      ((no_gpg_check)) && install_flags+=(--allow-unsigned-rpm) ;;
  esac

  # Install packages if any need installation
  if [[ ${#pkg_array[@]} -gt 0 ]]; then
    if ! "${PKG_INSTALL[@]}" "${install_flags[@]}" "${pkg_array[@]}"; then     
      ((silent)) || err "Failed to install ${pkg_array[*]}"
      return 1
    fi
  fi
  return 0
}

# @description install host-specific external repos
install_external_repos() {
  debug "Running: ${FUNCNAME[0]}"

  case $ID in
    ubuntu)
      if ! grep ^deb /etc/apt/sources.list.d/* | grep -q universe; then
        echo "Adding universe repository"
        if ! execute sudo add-apt-repository -y universe; then
          err "Adding universe repository failed"
        fi
      fi
      ;;
    centos)
      if ! command -v dpkg &>/dev/null; then
        echo "Adding EPEL repository"
        if ! install_package epel-release; then
          # If epel-release is not available, install it manually
          install_package --no-install-check \
            "https://dl.fedoraproject.org/pub/epel/epel-release-latest-${VERSION_ID%%.*}.noarch.rpm"
        fi
      fi
      if ! "${PKG_QUERY[@]}" rpmfusion-free-release &>/dev/null; then
        echo "Installing the RPMFusion repository"
        install_package --no-install-check \
          "https://download1.rpmfusion.org/free/el/rpmfusion-free-release-${VERSION_ID%%.*}.noarch.rpm"
      fi
      # Install mesa-va-drivers-freeworld separately from the RPM using dnf swap
      # install_mesa_freeworld # no longer provided by RPMFusion for EL9, etc.
      ;;
    fedora)
      if ! "${PKG_QUERY[@]}" rpmfusion-free-release &>/dev/null; then
        echo "Installing the RPMFusion repository"
        install_package --no-install-check \
          "https://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$VERSION_ID.noarch.rpm"
      fi
      # Install mesa-va-drivers-freeworld separately from the RPM using dnf swap
      install_mesa_freeworld
      ;;
    suse) : # TODO may eventually be needed if X11_XOrg is not available by default
      # if ! zypper repos | grep -q "X11_XOrg"; then
      #   echo "Installing the X11 repository"
      #   execute sudo zypper  --non-interactive --quiet addrepo \
      #     "https://download.opensuse.org/repositories/X11:/XOrg/${NAME// /_}/X11:XOrg.repo"
      #   execute sudo zypper  --non-interactive --quiet refresh
      # fi
      ;;
  esac
}

# @description Installs mesa-va-drivers-freeworld
install_mesa_freeworld() {
  debug "Running: ${FUNCNAME[0]}"

  swap_or_install_freeworld_package() {
    local pkg=$1
    local freeworld_pkg="${pkg}-freeworld"

    if ! "${PKG_QUERY[@]}" "$freeworld_pkg" &>/dev/null; then
      if "${PKG_QUERY[@]}" "$pkg" &>/dev/null; then
        if ! execute sudo dnf swap -y "$pkg" "$freeworld_pkg"; then
          err "Package swap failed for $pkg!"
        fi
      else
        "${PKG_INSTALL[@]}" "$freeworld_pkg"
      fi
    fi
  }

  swap_or_install_freeworld_package "mesa-va-drivers"
  swap_or_install_freeworld_package "mesa-vdpau-drivers"
}

# @description Installs JRiver Media Center from a remote repository
install_mc_repo() {
  debug "Running: ${FUNCNAME[0]}"
  local repo_file repo_text channel

  case $ID in
    fedora|centos)
      repo_file="/etc/yum.repos.d/jriver.repo"
      read -r -d '' repo_text <<-EOF
				[jriver]
				name=JRiver Media Center by BryanC
				baseurl=https://repos.bryanroessler.com/jriver
				gpgcheck=0
			EOF
      ;;
    debian|ubuntu)
      [[ -n $BETAPASS ]] && channel="beta" || channel="latest"
      local major_version="${VERSION_ID%%.*}"
      local minor_version="${VERSION_ID##*.}"
      local keyfile="/usr/share/keyrings/jriver-com-archive-keyring.gpg"
      if [[ $ID == "ubuntu" ]] \
      && [[ $major_version -gt 24 || ($major_version -eq 24 && $minor_version -ge 10) ]]; then
        if [[ $channel == "beta" ]]; then
          repo_file="/etc/apt/sources.list.d/jriver-beta.sources"
        else
          repo_file="/etc/apt/sources.list.d/jriver.sources"
        fi

        old_repo_files=(
          "/etc/apt/sources.list.d/jriver.list"
          "/etc/apt/sources.list.d/jriver-beta.list"
          "/etc/apt/sources.list.d/jriver_beta.list"
        )

        for f in "${old_repo_files[@]}"; do
          [[ -f $f ]] && execute sudo rm -f "$f"
        done
        read -r -d '' repo_text <<-EOF
					Types: deb
					URIs: http://dist.jriver.com/$channel/mediacenter/
					Signed-By: $keyfile
					Suites: $MC_REPO
					Components: main
				EOF
      else
        if [[ $channel == "beta" ]]; then
          execute sudo rm -f "/etc/apt/sources.list.d/jriver_beta.list"
          repo_file="/etc/apt/sources.list.d/jriver-beta.list"
        else
          repo_file="/etc/apt/sources.list.d/jriver.list"
        fi
        repo_text="deb [signed-by=$keyfile arch=amd64,i386,armhf,arm64] http://dist.jriver.com/$channel/mediacenter/ $MC_REPO main"
      fi
      echo "Installing JRiver Media Center RPM key"
      download "http://dist.jriver.com/mediacenter@jriver.com.gpg.key" | 
      gpg --dearmor | sudo tee "$keyfile" &>/dev/null
      ;;
    *)
      err "An MC repository for $ID is not yet available"
      err "Use --install local to install MC on $ID"
      return 1
      ;;
  esac

  echo "Adding MC repository file: $repo_file"
  debug "repo_text: $repo_text"
  sudo tee "$repo_file" &>/dev/null <<< "$repo_text"

  if ! "${PKG_UPDATE[@]}"; then
    err "Package update failed!"
    return 1
  fi

  if ! install_package \
    --no-install-check \
    --allow-downgrades \
    --no-gpg-check \
    "$MC_PKG"; then
    err "Package install failed!"
    return 1
  fi
}

# @description Acquires the source DEB package from JRiver
acquire_deb() {
  debug "Running: ${FUNCNAME[0]}"
  declare -g MC_SOURCE
  local fname

  # Usually JRiver exlcudes the release number from the filename
  # but in some cases (test builds) it may be included
  if [[ $MC_RELEASE -gt 1 ]]; then
    fname="MediaCenter-$MC_VERSION-$MC_RELEASE-$ARCH.deb"
  else
    fname="MediaCenter-$MC_VERSION-$ARCH.deb"
  fi

  declare -g MC_DEB="$OUTPUT_DIR/SOURCES/$fname"

  # If deb file already exists, skip download
  if [[ -f $MC_DEB ]]; then
    if [[ $(stat -c%s "$MC_DEB") -lt 10000000 ]]; then
      echo "Removing existing DEB under 10MB: $MC_DEB"
      execute rm "$MC_DEB"
    else
      echo "Using existing DEB: $MC_DEB"
      return 0
    fi
  fi

  # Define the repositories to check
  local repos=(
    "https://files.jriver-cdn.com/mediacenter/channels/v$MC_MVERSION/latest/$fname"
    "https://files.jriver-cdn.com/mediacenter/test/$fname")

  if [[ -n $BETAPASS ]]; then
    repos=("https://files.jriver-cdn.com/mediacenter/channels/v$MC_MVERSION/beta/$BETAPASS/$fname" "${repos[@]}")
  fi

  # Loop through the repositories and attempt to download
  local found=0
  for repo in "${repos[@]}"; do
    echo "Checking $repo for DEB package"
    if download "$repo" "$MC_DEB"; then
      echo "Found"
      found=1
      MC_SOURCE="$repo"
      break
    fi
  done

  # Return if the download was successful
  ((found)) && [[ -f $MC_DEB ]]
}

# @description Creates a SPEC file and builds the RPM from the source DEB using rpmbuild
build_rpm() {
  debug "Running: ${FUNCNAME[0]}"

  local i rpmbuild_cmd stub
  local -a requires recommends

  # skip rebuilding the rpm if it already exists
  if [[ -f $MC_RPM ]]; then
    echo "$MC_RPM already exists. Skipping build step"
    return 0
  fi

  # Load deb dependencies into array
  IFS=',' read -ra requires <<< "$(dpkg-deb -f "$MC_DEB" Depends)"
  IFS=',' read -ra recommends <<< "$(dpkg-deb -f "$MC_DEB" Recommends)"

  # Clean up formatting
  requires=("${requires[@]%%|*}")
  requires=("${requires[@]/?:/}")
  requires=("${requires[@]# }")
  requires=("${requires[@]% }")
  requires=("${requires[@]//\(/}")
  requires=("${requires[@]//)/}")
  recommends=("${recommends[@]%%|*}")
  recommends=("${recommends[@]/?:/}")
  recommends=("${recommends[@]# }")
  recommends=("${recommends[@]% }")
  recommends=("${recommends[@]//\(/}")
  recommends=("${recommends[@]//)/}")

  # Translate package names
  case $BUILD_TARGET in
    fedora|centos)
      requires=("${requires[@]/libc6/glibc}")
      requires=("${requires[@]/libasound2/alsa-lib}")
      requires=("${requires[@]/libuuid1/libuuid}")
      requires=("${requires[@]/libx11-6/libX11}")
      requires=("${requires[@]/libxext6/libXext}")
      requires=("${requires[@]/libxcb1*/libxcb}") # TODO Remove minimum version for MC31 (*)
      requires=("${requires[@]/libxdmcp6/libXdmcp}")
      requires=("${requires[@]/libstdc++6/libstdc++}")
      requires=("${requires[@]/libgtk-3-0/gtk3}")
      requires=("${requires[@]/libgl1/mesa-libGL}")
      requires=("${requires[@]/libpango-1.0-0/pango}")
      requires=("${requires[@]/libpangoft2-1.0-0/pango}")
      requires=("${requires[@]/libpangox-1.0-0/pango}")
      requires=("${requires[@]/libpangoxft-1.0-0/pango}")
      requires=("${requires[@]/libnss3/nss}")
      requires=("${requires[@]/libnspr4/nspr}")
      requires=("${requires[@]/libgomp1/libgomp}")
      requires=("${requires[@]/libfribidi0/fribidi}")
      requires=("${requires[@]/libfontconfig1/fontconfig}")
      requires=("${requires[@]/libfreetype6/freetype}")
      requires=("${requires[@]/libharfbuzz0b/harfbuzz}")
      requires=("${requires[@]/libgbm1/mesa-libgbm}")
      requires=("${requires[@]/libva2/libva}")
      requires=("${requires[@]/libva-drm2/libva}")
      requires=("${requires[@]/libepoxy0/libepoxy}")
      requires=("${requires[@]/liblcms2-2/lcms2}")
      requires=("${requires[@]/libvulkan1/vulkan-loader}")
      requires=("${requires[@]/libepoxy0/libepoxy}")
      requires=("${requires[@]/python/python3}")
      requires=("${requires[@]/libwebkit2gtk-4.0*/webkit2gtk4.0}")
      requires=("${requires[@]/libwebkit2gtk-4.1*/webkit2gtk4.1}")
      recommends+=(mesa-va-drivers-freeworld)
      ;;
    suse)
      requires=("${requires[@]/python/python3}")
      requires=("${requires[@]/libc6/glibc}")
      requires=("${requires[@]/libasound2/alsa-lib}")
      requires=("${requires[@]/libx11-6/libX11-6}")
      requires=("${requires[@]/libxext6/libXext6}")
      requires=("${requires[@]/libxdmcp6/libXdmcp6}")
      requires=("${requires[@]/libgtk-3-0/gtk3}")
      requires=("${requires[@]/libgl1/Mesa-libGL1}")
      requires=("${requires[@]/libpango-1.0-0/pango}")
      requires=("${requires[@]/libpangoft2-1.0-0/pango}")
      requires=("${requires[@]/libpangox-1.0-0/pango}")
      requires=("${requires[@]/libpangoxft-1.0-0/pango}")
      requires=("${requires[@]/libnss3/mozilla-nss}")
      requires=("${requires[@]/libnspr4/mozilla-nspr}")
      requires=("${requires[@]/libfribidi0/fribidi}")
      requires=("${requires[@]/libfontconfig1/fontconfig}")
      requires=("${requires[@]/libharfbuzz0b/libharfbuzz0}")
      requires=("${requires[@]/libwebkit2gtk-4.0*/libwebkit2gtk-4_0-37}")
      requires=("${requires[@]/libwebkit2gtk-4.1*/libwebkit2gtk-4_1-0}")
      for i in "${!requires[@]}"; do
        [[ ${requires[$i]} == "mesa-vulkan-drivers" ]] && unset -v 'requires[i]'
      done
      recommends+=(libvulkan_intel)
      recommends+=(libvulkan_radeon)
      ;;
  esac

  # Convert array to newline delim'd string (for heredoc)
  printf -v requires "Requires: %s\n" "${requires[@]}"
  printf -v recommends "Recommends: %s\n" "${recommends[@]}"
  # Strip last newline
  requires="${requires%?}" 
  recommends="${recommends%?}"

  if ((COMPAT_SWITCH)); then
    # Strip minimum versions
    requires=$(echo "$requires" | awk -F" " 'NF == 4 {print $1 " " $2} NF != 4 {print $0}')
  fi

  # Exclude MC stub executable <= MC31
  if [[ $MC_MVERSION -le 31 ]]; then
    stub=""
  else
    stub="%{_bindir}/mc$MC_MVERSION"
  fi

  # Create spec file
  cat <<-EOF > "$OUTPUT_DIR/SPECS/mediacenter.spec"
		Name:  mediacenter$MC_MVERSION
		Version: $MC_VERSION
		Release: $MC_RELEASE
		Summary: JRiver Media Center
		Group:   Applications/Media
		Source0: $MC_SOURCE
		BuildArch: x86_64
		%define _rpmfilename %%{ARCH}/%%{NAME}-%%{version}-%%{release}.%%{ARCH}.rpm

		AutoReq:  0

		$requires
		$recommends

		Conflicts: MediaCenter

		Provides: mediacenter$MC_MVERSION

		License: Copyright 1998-$(date +%Y), JRiver, Inc.  All rights reserved.  Protected by U.S. patents #7076468 and #7062468
		URL: http://www.jriver.com/

		%define __provides_exclude_from ^%{_libdir}/jriver/.*/.*\\.so.*$

		%description
		Media Center is more than a world class player.

		%global __os_install_post %{nil}
		%prep

		%build

		%install
		dpkg -x %{S:0} %{buildroot}

		%post -p /sbin/ldconfig
		%postun -p /sbin/ldconfig

		%files
		%{_bindir}/mediacenter$MC_MVERSION
		$stub
		%{_libdir}/jriver
		%{_datadir}
		%exclude %{_datadir}/applications/media_center_packageinstaller_$MC_MVERSION.desktop
		/etc/security/limits.d/*
	EOF

  # Run rpmbuild
  echo "Building MC $MC_VERSION RPM, this may take some time"
  rpmbuild_cmd=(
    rpmbuild 
      --define="%_topdir $OUTPUT_DIR" 
      --define="%_libdir /usr/lib" 
      -bb
      "$OUTPUT_DIR/SPECS/mediacenter.spec"
  )
  if execute "${rpmbuild_cmd[@]}" && [[ -f $MC_RPM ]] ; then
    echo "Build successful. The RPM file is located at: $MC_RPM"
  else
    err "Build failed"
    # After failire, remove the source DEB and reaquire it on next run
    [[ -f $MC_DEB ]] && echo "Removing source DEB" && execute rm -f "$MC_DEB"
    exit 1
  fi
}

# @description Installs Media Center DEB package and optional compatability fixes
install_mc_deb() {
  debug "Running: ${FUNCNAME[0]}"  

  if ((COMPAT_SWITCH)); then
    local extract_dir; extract_dir="$(mktemp -d)"
    pushd "$extract_dir" &>/dev/null || return
    command -v ar &>/dev/null || { install_package binutils || return 1; }
    execute ar x "$MC_DEB"
    execute tar xJf "control.tar.xz"
    # Remove minimum version specifiers from control file
    sed -i 's/ ([^)]*)//g' "control"
    # Remove libwebkit2gtk and their fantastic package versioning strategy
    sed -i 's/,\s*libwebkit2gtk[^,]*,\?|libwebkit2gtk[^,]*,\?//g' "control"

    # TODO workaround for ZorinOS
    [[ $ID == "ubuntu" && ${VERSION_ID%.*} -le 16 ]] \
    && grep -q zorin /etc/os-release \
    && sed -i 's/libva2/libva1/g' "control"

    execute tar -cJf "control.tar.xz" "control" "postinst"
    declare -g MC_DEB="${MC_DEB/.deb/.compat.deb}"
    execute ar rcs "$MC_DEB" "debian-binary" "control.tar.xz" "data.tar.xz"
    popd &>/dev/null || return
    execute rm -rf "$extract_dir"
  fi

  # Use --reinstall to make sure local package is installed over repo package
  if ! install_package \
    --no-install-check \
    --no-gpg-check \
    --allow-downgrades \
    --reinstall \
    "$MC_DEB"; then
    err "Local MC DEB installation failed"
    err "Only the default MC repo can be used for --install=local"
    if ask_ok "Remove source DEB and retry"; then
      execute rm -f "$MC_DEB"
      exec "$SCRIPT_PATH" "$@" "--no-update"
    else
      return 1
    fi
  fi
}

# @description Installs Media Center RPM package on RHEL distros
install_mc_rhel() {
  debug "Running: ${FUNCNAME[0]}"
  install_package --no-install-check --no-gpg-check --allow-downgrades "$MC_RPM"
}

# @description Installs Media Center RPM package on SUSE
install_mc_suse() {
  debug "Running: ${FUNCNAME[0]}"
  install_package --no-install-check --no-gpg-check --allow-downgrades "$MC_RPM"
}

# @description Installs Media Center generically for unsupported OSes
install_mc_generic() {
  debug "Running: ${FUNCNAME[0]}"
  local extract_dir
  local -a raw_files

  echo "Using generic installation method"

  extract_dir="$(mktemp -d)"
  pushd "$extract_dir" &>/dev/null || return
  execute ar x "$MC_DEB"
  execute tar xJf "control.tar.xz"
  echo "You must install the following dependencies manually:"
  grep -i "Depends:" control
  readarray -t raw_files < <(tar xJvf data.tar.xz)
  # Output to log file
  for f in "${raw_files[@]/#./}"; do
    echo "$f" >> "$SCRIPT_DIR/.uninstall"
  done
  # Manually install files
  for f in "${raw_files[@]}"; do
    execute sudo cp -a "$f" "${f/#./}"
  done
  popd &>/dev/null || return
  execute rm -rf "$extract_dir"
  return 0
}

# @description Installs Media Center Arch PKGBUILD
install_mc_arch() {
  debug "Running: ${FUNCNAME[0]}"

  [[ -d $OUTPUT_DIR/PKGBUILD ]] || execute mkdir -p "$OUTPUT_DIR/PKGBUILD"

  cat <<-EOF > "$OUTPUT_DIR/PKGBUILD/mediacenter.pkgbuild"
		pkgname=mediacenter$MC_MVERSION
		pkgver=$MC_VERSION
		pkgrel=1
		pkgdesc="The Most Comprehensive Media Software"
		arch=('x86_64')
		url="http://www.jriver.com/"
		license=('custom')
		depends=('alsa-lib' 'ca-certificates' 'gtk3' 'gcc-libs' 'libx11' 'libxext' 'libxcb' 'libxau' 'libxdmcp' 'util-linux' 'mesa-libgl' 'webkit2gtk')
		optdepends=(
			'mesa-libgl: nouveau video support' 
			'nvidia-libgl: nvidia video support' 
			'nvidia-utils: nvidia vulkan support' 
			'vulkan-intel: intel vulkan support' 
			'vulkan-radeon: amd vulkan support' 
			'vorbis-tools: ogg vorbis support' 
			'musepack-tools: musepack support'
		)
		source=("http://files.jriver-cdn.com/mediacenter/channels/v$MC_MVERSION/latest/MediaCenter-$MC_VERSION-$ARCH.deb")

		package() {
			cd "\$srcdir"
			bsdtar xf data.tar.xz -C "\$pkgdir"
		}
	EOF
  
  pushd "$OUTPUT_DIR/PKGBUILD" &>/dev/null || return

  if ! execute makepkg \
    --install \
    --syncdeps \
    --clean \
    --cleanbuild \
    --skipinteg \
    --force \
    --noconfirm \
    -p mediacenter.pkgbuild; then
    err "makepkg failed"; exit 1
  fi

  popd &>/dev/null || return
}

# @description Copy the RPM to createrepo-webroot and run createrepo as the createrepo-user
run_createrepo() {
  debug "Running: ${FUNCNAME[0]}"
  local -a cr_cmd

  install_package createrepo_c

  # Ensure the webroot exists
  if [[ ! -d $CREATEREPO_WEBROOT ]]; then
    if ! execute sudo -u "$CREATEREPO_USER" mkdir -p "$CREATEREPO_WEBROOT"; then
      if ! (execute sudo mkdir -p "$CREATEREPO_WEBROOT" \
      || execute sudo chown -R "$CREATEREPO_USER:$CREATEREPO_USER" "$CREATEREPO_WEBROOT"); then
        err "Could not create the createrepo-webroot path!"
        err "Make sure that the webroot $CREATEREPO_WEBROOT is writable by user $CREATEREPO_USER"
        err "Or change the repo ownership with --createrepo-user"
        return 1
      fi
    fi
  fi

  # Copy built RPMs to webroot
  if ! execute sudo cp -nf "$MC_RPM" "$CREATEREPO_WEBROOT" \
  || ! execute sudo chown -R "$CREATEREPO_USER:$CREATEREPO_USER" "$CREATEREPO_WEBROOT"; then
    err "Could not copy $MC_RPM to $CREATEREPO_WEBROOT"
    return 1
  fi

  # Run createrepo
  cr_cmd=(sudo -u "$CREATEREPO_USER" createrepo -q "$CREATEREPO_WEBROOT")
  [[ -d $CREATEREPO_WEBROOT/repodata ]] && cr_cmd+=(--update)
  
  if ! execute "${cr_cmd[@]}"; then
    cr_cmd=(sudo createrepo -q "$CREATEREPO_WEBROOT")
    [[ -d $CREATEREPO_WEBROOT/repodata ]] && cr_cmd+=(--update)
    
    if ! (execute "${cr_cmd[@]}" \
    || execute sudo chown -R "$CREATEREPO_USER:$CREATEREPO_USER" "$CREATEREPO_WEBROOT"); then
      err "createrepo failed"
      return 1
    fi
  fi
}

# @description Symlink certificates if they do not exist in default location
link_ssl_certs() {
  debug "Running: ${FUNCNAME[0]}"
  local target_cert f
  local mc_cert_link="$MC_ROOT/ca-certificates.crt"
  local -a source_certs=(
    "/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem" 
    "/var/lib/ca-certificates/ca-bundle.pem"
    "$MC_ROOT/local-ca-certificates.crt")

  target_cert=$(readlink -f "$mc_cert_link")
  [[ -f $target_cert ]] && return 0

  for f in "${source_certs[@]}"; do
    if [[ -f $f ]]; then
      if execute sudo ln -fs "$f" "$mc_cert_link"; then
        debug "Symlinked $mc_cert_link to $f"
        return 0
      fi
    fi
  done
  err "Certificate symlinking failed"; return 1
}

# @description Restore the mjr license file from MJR_FILE or other common locations
restore_license() {
  debug "Running: ${FUNCNAME[0]}"
  local newest f
  local -a mjrfiles

  # Glob mjr files from common directories
  shopt -s nullglob
  mjrfiles=(
    "$SCRIPT_DIR"/*.mjr 
    "$OUTPUT_DIR"/*.mjr 
    "$HOME"/[dD]ownloads/*.mjr
    "$HOME"/[dD]ocuments/*.mjr
  )
  shopt -u nullglob

  if [[ ${#mjrfiles[@]} -gt 0 ]]; then

    debug "mjrfiles=(${mjrfiles[*]})"

    # Sort globbed files by time, newest first
    newest=${mjrfiles[0]}
    for f in "${mjrfiles[@]}"; do
      if [[ -f $f && $f -nt $newest ]]; then
        newest=$f
      fi
    done

    debug "Latest mjrfile: $newest"

    for f in "$MJR_FILE" "$newest"; do
      if [[ -f $f ]]; then
        execute "mediacenter$MC_MVERSION" "/RestoreFromFile" "$f"
      fi
    done
  fi
}

# @description Opens ports using the system firewall tool
# @arg $1 string Service name
# @arg $2 array List of ports in firewall-cmd format
open_firewall() {
  debug "Running: ${FUNCNAME[0]}" "$*"
  local service="$1"
  shift
  local -a f_ports=("$@") # for firewall-cmd
  local u_ports="$*"
  u_ports="${u_ports// /|}" # concatenate
  u_ports="${u_ports//-/\:}" # for ufw
  local port

  if command -v firewall-cmd &>/dev/null; then
    if ! sudo firewall-cmd --get-services | grep -q "$service"; then
      execute sudo firewall-cmd --permanent "--new-service=$service"
      execute sudo firewall-cmd --permanent "--service=$service" "--set-description=$service" installed by installJRMC
      execute sudo firewall-cmd --permanent "--service=$service" "--set-short=$service"
      for port in "${f_ports[@]}"; do
        execute sudo firewall-cmd --permanent "--service=$service" "--add-port=$port"
      done
      execute sudo firewall-cmd --add-service "$service" --permanent
      execute sudo firewall-cmd --reload
    fi
  elif command -v ufw &>/dev/null; then
    sudo bash -c "cat <<-EOF > /etc/ufw/applications.d/$service
			[$service]
			title=$service
			description=$service installed by installJRMC
			ports=$u_ports
		EOF"
    execute sudo ufw app update "$service"
    execute sudo ufw allow "$service"
  else
    echo "Warning: Install firewall-cmd or ufw to open firewall ports"
    return 1
  fi
}

# @description Create the xvnc or x11vnc password file
# @arg $1 string Service type (xvnc, x11vnc)
set_vnc_pass() {
  debug "Running: ${FUNCNAME[0]}"
  local vncpassfile="$HOME/.vnc/jrmc_passwd"

  [[ -d ${vncpassfile%/*} ]] || execute mkdir -p "${vncpassfile%/*}"

  if [[ -f $vncpassfile ]]; then
    if [[ ! -v VNCPASS ]]; then
      err "Refusing to overwrite existing $vncpassfile with an empty password"
      err "Remove existing $vncpassfile or use --vncpass ''"
      return 1
    else
      execute rm -f "$vncpassfile"
    fi
  fi

  if [[ -v VNCPASS ]]; then
    if [[ $1 == "xvnc" ]]; then
      echo "$VNCPASS" | vncpasswd -f > "$vncpassfile"
    elif [[ $1 == "x11vnc" ]]; then
      execute x11vnc -storepasswd "$VNCPASS" "$vncpassfile"
    fi
    return
  else
    declare -gi NOVNCAUTH=1
  fi
}

# @description Set display and port variables
set_display_vars() {
  debug "Running: ${FUNCNAME[0]}"
  declare -g THIS_DISPLAY THIS_DISPLAY_NUM NEXT_DISPLAY

  # Check USER_DISPLAY, else environment DISPLAY, else set to :0
  THIS_DISPLAY="${USER_DISPLAY:-${DISPLAY:-:0}}"
  THIS_DISPLAY_NUM="${THIS_DISPLAY#*:}" # strip prefix
  THIS_DISPLAY_NUM="${THIS_DISPLAY_NUM%%.*}" # strip suffix
  # Increment each time we run this
  if ((NEXT_DISPLAY_NUM)); then
    declare -g NEXT_DISPLAY_NUM=$((NEXT_DISPLAY_NUM + 1))
  else
    declare -g NEXT_DISPLAY_NUM=$((THIS_DISPLAY_NUM + 1))
  fi
  NEXT_DISPLAY=":$NEXT_DISPLAY_NUM"
}

# @description Create associated service variables based on service name
# @arg $1 string Service name
set_service_vars() {
  debug "Running: ${FUNCNAME[0]}" "$*"
  declare -g SERVICE_NAME SERVICE_FNAME TIMER_NAME TIMER_FNAME 
  declare -g USER_STRING GRAPHICAL_TARGET
  declare -ga RELOAD ENABLE DISABLE IS_ENABLED IS_ACTIVE
  local -a systemctl_prefix
  local service_name="$1"
  local service_type="${SERVICE_TYPE:-${2:-system}}"
  local service_dir="/usr/lib/systemd/$service_type"

  if [[ $USER == "root" && $service_type == "user" ]]; then
    err "Trying to install user service as root"
    err "Use --service-type service and/or execute installJRMC as non-root user"
    return 1
  fi

  if [[ $service_type == "system" ]]; then
    systemctl_prefix=(sudo systemctl)
    GRAPHICAL_TARGET="graphical.target"
  elif [[ $service_type == "user" ]]; then
    systemctl_prefix=(systemctl --user)
    GRAPHICAL_TARGET="default.target"
  fi

  # systemctl commands
  RELOAD=(execute "${systemctl_prefix[@]}" daemon-reload)
  ENABLE=(execute "${systemctl_prefix[@]}" enable --now)
  DISABLE=(execute "${systemctl_prefix[@]}" disable --now)
  IS_ENABLED=(execute "${systemctl_prefix[@]}" is-enabled -q)
  IS_ACTIVE=(execute "${systemctl_prefix[@]}" is-active -q)

  [[ -d $service_dir ]] || execute sudo mkdir -p "$service_dir"

  if [[ $service_type == "system" && $USER != "root" ]]; then
    SERVICE_FNAME="$service_dir/$service_name@.service"
    TIMER_FNAME="$service_dir/$service_name@.timer"
    SERVICE_NAME="$service_name@$USER.service"
    TIMER_NAME="$service_name@$USER.timer"
    USER_STRING="User=%I"
  else
    SERVICE_NAME="$service_name.service"
    TIMER_NAME="$service_name.timer"
    SERVICE_FNAME="$service_dir/$SERVICE_NAME"
    TIMER_FNAME="$service_dir/${TIMER_NAME}"
    USER_STRING=""
  fi
}

# @section Services
# @description Starts and enables (at startup) a JRiver Media Center service
# @arg $1 string Passes arguments as startup options to /usr/bin/mediacenter??
service_jriver-mediacenter() {
  debug "Running: ${FUNCNAME[0]}"

  set_service_vars "${FUNCNAME[0]##*_}" "user"

  sudo bash -c "cat <<-EOF > $SERVICE_FNAME
		[Unit]
		Description=JRiver Media Center $MC_MVERSION
		After=$GRAPHICAL_TARGET

		[Service]
		Type=simple
		$USER_STRING
		ExecStart=/usr/bin/mediacenter$MC_MVERSION $*
		KillMode=none
		ExecStop=/usr/bin/mc$MC_MVERSION /MCC 20007
		Restart=always
		RestartSec=10
		TimeoutStopSec=30

		[Install]
		WantedBy=$GRAPHICAL_TARGET
	EOF"

  open_firewall "jriver-mediacenter" "52100-52200/tcp" "1900/udp"

  "${RELOAD[@]}" \
  && "${ENABLE[@]}" "$SERVICE_NAME"
}

# @description Starts and enables (at startup) a JRiver Media Server service
service_jriver-mediaserver() {
  debug "Running: ${FUNCNAME[0]}"
  set_service_vars "${FUNCNAME[0]##*_}" "user"
  service_jriver-mediacenter "/MediaServer"
}

# @description Starts and enables (at startup) JRiver Media Center in a new Xvnc session
# TODO https://github.com/TigerVNC/tigervnc/blob/master/unix/vncserver/HOWTO.md
service_jriver-xvnc() {
  debug "Running: ${FUNCNAME[0]}"
  local -a start_cmd

  set_service_vars "${FUNCNAME[0]##*_}" "system"
  set_display_vars
  declare -g PORT=$((NEXT_DISPLAY_NUM + 5900))

  install_package tigervnc-server
  set_vnc_pass xvnc

  start_cmd=(
    /usr/bin/vncserver "$NEXT_DISPLAY"
    -geometry 1440x900 
    -alwaysshared
    -autokill
    -xstartup "/usr/bin/mediacenter$MC_MVERSION"
  )

  if ((NOVNCAUTH)); then
    start_cmd+=(
      -name "jriver$NEXT_DISPLAY" 
      -SecurityTypes None)
  else
    start_cmd+=(
      -rfbauth "$HOME/.vnc/jrmc_passwd")
  fi

  sudo bash -c "cat <<-EOF > $SERVICE_FNAME
		[Unit]
		Description=Remote desktop service (VNC)
		After=multi-user.target

		[Service]
		Type=forking
		$USER_STRING
		ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill $NEXT_DISPLAY &>/dev/null || :'
		ExecStart=${start_cmd[*]}
		ExecStop=/usr/bin/vncserver -kill $NEXT_DISPLAY
		Restart=always

		[Install]
		WantedBy=multi-user.target
	EOF"

  "${RELOAD[@]}"

  if ! "${ENABLE[@]}" "$SERVICE_NAME"; then
    err "vncserver failed to start on DISPLAY $NEXT_DISPLAY"
    # Allow to increment 10 times before breaking
    max=$((THIS_DISPLAY_NUM + 10))
    while [[ $NEXT_DISPLAY_NUM -lt $max ]]; do
      echo "Incrementing DISPLAY and retrying"
      service_jriver-xvnc && return
    done
    return 1
  else
    echo "Xvnc running on localhost:$PORT"
    open_firewall "jriver-xvnc" "$PORT/tcp"
    open_firewall "jriver-mediacenter" "52100-52200/tcp" "1900/udp"
    return 0
  fi
}

# @description Starts and enables (at startup) x11vnc screen sharing for the local desktop
service_jriver-x11vnc() {
  debug "Running: ${FUNCNAME[0]}"
  local -a start_cmd
  set_service_vars "${FUNCNAME[0]##*_}" "user"
  set_display_vars
  declare -g PORT=$((THIS_DISPLAY_NUM + 5900))
  install_package x11vnc
  set_vnc_pass x11vnc

  # If .Xauthority file is missing, generate a dummy for x11vnc -auth guess
  if [[ ! -f "$HOME/.Xauthority" ]]; then
    [[ $XDG_SESSION_TYPE == "wayland" ]] && 
    ask_ok "Unsupported Wayland session detected for x11vnc, continue?" || return 1
    debug "Generating $HOME/.Xauthority"
    execute touch "$HOME/.Xauthority"
    execute chmod 644 "$HOME/.Xauthority"
    xauth generate "$DISPLAY" . trusted
    xauth add "$HOST$DISPLAY" . "$(xxd -l 16 -p /dev/urandom)"
  fi

  start_cmd=(
    /usr/bin/x11vnc 
    -display "$DISPLAY"
    -noscr
    -auth guess
    -forever
    -bg
  )

  if ((NOVNCAUTH)); then
    start_cmd+=(-nopw)
  else
    start_cmd+=(-rfbauth "$HOME/.vnc/jrmc_passwd")
  fi

  sudo bash -c "cat <<-EOF > $SERVICE_FNAME
		[Unit]
		Description=x11vnc
		After=$GRAPHICAL_TARGET

		[Service]
		$USER_STRING
		Type=forking
		Environment=DISPLAY=$DISPLAY
		ExecStart=${start_cmd[*]}
		Restart=always
		RestartSec=10

		[Install]
		WantedBy=$GRAPHICAL_TARGET
	EOF"

  open_firewall "jriver-x11vnc" "$PORT/tcp"

  "${RELOAD[@]}" \
  && "${ENABLE[@]}" "$SERVICE_NAME" \
  && echo "x11vnc running on localhost:$PORT"
}

# @description Starts and enables (at startup) an hourly service to build the latest version of
# JRiver Media Center RPM from the source DEB and create/update an RPM repository
service_jriver-createrepo() {
  debug "Running: ${FUNCNAME[0]}"

  if [[ $CREATEREPO_USER != "$USER" ]]; then
    USER="root" set_service_vars "${FUNCNAME[0]##*_}" "system"
  else
    set_service_vars "${FUNCNAME[0]##*_}" "system"
  fi

  sudo bash -c "cat <<-EOF > $SERVICE_FNAME
		[Unit]
		Description=Builds JRiver Media Center RPM, moves it to the repo dir, and runs createrepo

		[Service]
		$USER_STRING
		ExecStart=$SCRIPT_DIR/installJRMC --outputdir=$OUTPUT_DIR --createrepo=$CREATEREPO_TARGET \
      --createrepo-webroot=$CREATEREPO_WEBROOT --createrepo-user=$CREATEREPO_USER --yes --no-update

		[Install]
		WantedBy=multi-user.target
	EOF"

  sudo bash -c "cat <<-EOF > $TIMER_FNAME
		[Unit]
		Description=Run JRiver MC rpmbuild hourly

		[Timer]
		OnCalendar=hourly
		Persistent=true

		[Install]
		WantedBy=timers.target
	EOF"

  "${RELOAD[@]}" \
  && "${ENABLE[@]}" "$TIMER_NAME"
}

# @description Detects if MC is installed on btrfs and disables CoW
disable_btrfs_cow() {
  debug "Running: ${FUNCNAME[0]}"
  local dir 
  local mc_user_path="$HOME/.jriver"

  for dir in "$MC_ROOT" "$mc_user_path"; do
    [[ -d $dir ]] || execute mkdir -p "$dir"
    if [[ $(stat -f -c %T "$dir") == "btrfs" ]] \
    && ! lsattr -d "$dir" | cut -f1 -d" " | grep -q C \
    && execute sudo chattr +C "$dir"; then
      echo "Disabled btrfs CoW for $dir directory"
    fi
  done
}

# @description Completely uninstalls MC, services, and firewall rules
uninstall() {
  debug "Running: ${FUNCNAME[0]}"
  local service type unit f

  echo "Stopping and removing all Media Center services"
  for service in $(compgen -A "function" "service"); do
    service="${service##service_}"
    for type in user system; do
      set_service_vars "$service" "$type"; 
      for unit in "$SERVICE_NAME" "$TIMER_NAME"; do
        if "${IS_ACTIVE[@]}" "$unit" || 
        "${IS_ENABLED[@]}" "$unit"; then
          "${DISABLE[@]}" "$unit"
        fi
      done
      for f in "$SERVICE_FNAME" "$TIMER_FNAME"; do
        [[ -f $f ]] && execute sudo rm -f "$f"
      done
      "${RELOAD[@]}"
    done
  done

  echo "Removing MC repositories"
  execute sudo rm -rf \
    "/etc/yum.repos.d/jriver.repo" \
    /etc/apt/sources.list.d/{jriver,mediacenter}*.{list,sources} # also remove legacy repo files

  if [[ $ID == "suse" ]]; then
    execute sudo zypper --non-interactive removerepo jriver
  fi

  echo "Removing firewall rules"
  for service in jriver-mediacenter jriver-xvnc jriver-x11vnc; do
    if command -v firewall-cmd &>/dev/null; then
      execute sudo firewall-cmd --permanent --remove-service=$service
      execute sudo firewall-cmd --permanent --delete-service=$service
      execute sudo firewall-cmd --reload
    elif command -v ufw &>/dev/null; then
      execute sudo ufw delete allow $service
      [[ -f /etc/ufw/applications.d/$service ]] &&
        execute sudo rm -f /etc/ufw/applications.d/$service
    fi
  done

  echo "Uninstalling JRiver Media Center package"
  if "${PKG_REMOVE[@]}" "${MC_PKG%%=*}"; then # remove version specifier
    echo "JRiver Media Center has been completely uninstalled"
    echo "To remove your MC library: rm -rf $HOME/.jriver"
  elif [[ $? -eq 100 ]]; then
    err "JRiver Media Center package '${MC_PKG%%=*}' is not present and was not uninstalled"
  else
    err "Could not remove Media Center package"
  fi

  if [[ -f $SCRIPT_DIR/.uninstall ]]; then
    echo "Removing files from .uninstall log"
    while read -r p; do
      [[ -d $p ]] && execute sudo rm -rf "$p"
    done < "$SCRIPT_DIR/.uninstall"
    mv "$SCRIPT_DIR/.uninstall" "$SCRIPT_DIR/.uninstall.bk"
  fi

  return 0
}

# @description Checks for installJRMC update and re-executes, if necessary
update() {
  debug "Running: ${FUNCNAME[0]} $*"
  debug "Checking for installJRMC update"

  # Extract and normalize version from a script
  extract_version() {
    local version_line
    version_line=$(grep -m 1 'SCRIPT_VERSION=' "$1")
    version_line=${version_line#*=}
    version_line=${version_line#\"}
    version_line=${version_line%-dev\"}
    version_line=${version_line%\"}
    echo "$version_line"
  }

  # Compare semantic version strings
  version_greater() {
    [[ "$(echo -e "$1\n$2" | sort -V | head -n 1)" != "$1" ]]
  }

  # Check if we're in a git directory and if it's the installJRMC repository
  if git -C "$SCRIPT_DIR" rev-parse --is-inside-work-tree &>/dev/null \
  && [[ "$(git -C "$SCRIPT_DIR" config --get remote.origin.url)" == *"installJRMC"* ]]; then

    # Get the current commit hash
    local before_pull_hash after_pull_hash
    before_pull_hash=$(git -C "$SCRIPT_DIR" rev-parse HEAD)

    # Stash local changes before pull
    execute git -C "$SCRIPT_DIR" stash push --quiet
    
    # Pull latest changes
    debug "Running git pull in $SCRIPT_DIR"
    if ! git -C "$SCRIPT_DIR" pull | grep -q "Already up to date"; then
      # Get the new commit hash after pull
      after_pull_hash=$(git -C "$SCRIPT_DIR" rev-parse HEAD)

      # If the commit hash has changed, an update occurred
      if [[ "$before_pull_hash" != "$after_pull_hash" ]]; then
        echo "Detected installJRMC update, restarting"
        execute git -C "$SCRIPT_DIR" stash pop --quiet
        exec "$SCRIPT_PATH" "$@" "--no-update"
      fi
    fi
    execute git -C "$SCRIPT_DIR" stash pop --quiet
  else
    debug "Not in a git repository or not the installJRMC repository. Checking for updates via download."

    local tmp
    tmp=$(mktemp) || { err "Failed to create temporary file."; return 1; }

    # Acquire the latest version of the script
    if ! download "$SCRIPT_URL" "$tmp"; then
      err "Failed to download the latest script."
      execute rm -f "$tmp"
      return 1
    fi

    # Extract the latest version number
    local remote_version
    remote_version=$(extract_version "$tmp")
    if [[ -z "$remote_version" ]]; then
      err "Failed to extract version from the downloaded script."
      execute rm -f "$tmp"
      return 1
    fi

    # Compare versions and update if the remote version is greater
    if version_greater "$remote_version" "$SCRIPT_VERSION"; then
      execute mv "$tmp" "$SCRIPT_PATH" || { err "Failed to replace the script"; execute rm -f "$tmp"; return 1; }
      execute chmod +x "$SCRIPT_PATH" || { err "Failed to make the script executable"; return 1; }
      execute rm -f "$tmp"

      echo "Detected installJRMC update, restarting"
      exec "$SCRIPT_PATH" "$@" "--no-update"
    else
      debug "Current installJRMC $SCRIPT_VERSION is the latest version"
      execute rm -f "$tmp"
      return 0
    fi
  fi
}

# @description installJRMC main function
main() {
  debug "Running: ${FUNCNAME[0]} $*"

  echo "Starting installJRMC $SCRIPT_VERSION"
  if ((DEBUG)); then
    echo "Debugging on"
  else
    echo "To enable debugging output, use --debug or -d"
  fi

  # Parse input, set default/host variables, and MC version
  init "$@"

  if ((UNINSTALL_SWITCH)); then
    if ask_ok "Do you really want to uninstall JRiver Media Center?"; then
      uninstall
    else
      echo "Uninstall canceled"
    fi
    exit
  fi

  install_external_repos

  if ((REPO_INSTALL_SWITCH)); then
    echo "Installing JRiver Media Center from remote repository"
    if install_mc_repo; then
      echo "JRiver Media Center installed successfully from remote repository"
      link_ssl_certs
      restore_license
      open_firewall "jriver-mediacenter" "52100-52200/tcp" "1900/udp"
      disable_btrfs_cow
    else
      err "JRiver Media Center installation from remote repository failed"
      return 1
    fi
  fi

  if ((BUILD_SWITCH)) && [[ $ID != "arch" ]]; then
    [[ -d $OUTPUT_DIR/SOURCES ]] || execute mkdir -p "$OUTPUT_DIR/SOURCES"
    acquire_deb || { err "Could not download Media Center DEB package"; return 1; }

    if [[ $BUILD_TARGET =~ centos|fedora|suse || $CREATEREPO_TARGET =~ centos|fedora|suse ]]; then
      install_package dpkg rpm-build
      [[ -d $OUTPUT_DIR/SPECS ]] || execute mkdir -p "$OUTPUT_DIR/SPECS"
      build_rpm
    fi
  fi

  if ((LOCAL_INSTALL_SWITCH)); then
    if PKG_INSTALL_LOCAL "$@"; then
      echo "JRiver Media Center installed successfully from local package"
    else
      err "JRiver Media Center local package installation failed"
      return 1
    fi
    link_ssl_certs
    restore_license
    open_firewall "jriver-mediacenter" "52100-52200/tcp" "1900/udp"
    disable_btrfs_cow
  fi

  if ((CREATEREPO_SWITCH)); then
    if run_createrepo; then
      echo "Successfully updated repo"
    else
      err "Repo creation failed"
    fi
  fi

  if [[ ${#SERVICES[@]} -gt 0 ]]; then
    declare service
    for service in "${SERVICES[@]}"; do
      if ! "service_$service"; then
        if [[ $? -eq 127 ]]; then
          err "Service $service does not exist, check service name"
        else
          err "Failed to create $service service"
        fi
      else
        echo "Started and enabled $service service"
      fi
    done
    unset service
  fi

  # for _container in "${CONTAINERS[@]}"; do
  #   if ! "_container_$_container"; then
  #     if [[ $? -eq 127 ]]; then
  #       err "Container $_container does not exist, check container name"
  #     else
  #       err "Failed to create container: $_container"
  #     fi
  #   fi
  # done
}

# @section Helper functions
debug() { ((DEBUG)) && echo "Debug: $*"; }
err() { echo "Error: $*" >&2; }
ask_ok() {
  local response
  ((YES_SWITCH)) && return 0
  read -r -p "$* [y/N]: " response
  [[ ${response,,} =~ ^(yes|y)$ ]]
}
execute() {
  if debug "$*"; then
    "$@"
  else
    "$@" &>/dev/null
  fi
}
download() {
  local url="$1"
  local output="${2:-}"
  local -a cmd

  if command -v curl &>/dev/null || install_package --silent curl; then
    cmd=(curl --silent --fail --location)
    if [[ -n "$output" ]]; then
      cmd+=(--output "$output")
    else
      cmd+=(-O)
    fi
  elif command -v wget &>/dev/null || install_package --silent wget; then
    cmd=(wget --quiet)
    [[ -n "$output" ]] && cmd+=("--output-document=$output")
  else
    err "Unable to install wget or curl"
    return 1
  fi

  "${cmd[@]}" "$url"
}

# Roughly turn debugging on for pre-init
# Reset and reparse in parse_input() with getopt
[[ " $* " =~ ( --debug | -d ) ]] && DEBUG=1

main "$@"
exit
